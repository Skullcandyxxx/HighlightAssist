diff --git a/src/highlight/DevConsole.jsx b/src/highlight/DevConsole.jsx
index d69261a..e1780d8 100644
--- a/src/highlight/DevConsole.jsx
+++ b/src/highlight/DevConsole.jsx
@@ -208,6 +208,7 @@ export function DevConsole() {
     return (
       <div
         className="ha-panel"
+        data-ha-ui="true"
         ref={panelRef}
         style={{
           width: 'auto',
@@ -234,6 +235,7 @@ export function DevConsole() {
     <div
       ref={panelRef}
       className="ha-panel"
+      data-ha-ui="true"
       style={{ width: 320 }}
     >
       <div className="ha-row ha-drag-handle">
diff --git a/src/highlight/GameOverlay.jsx b/src/highlight/GameOverlay.jsx
index 5f8eaa3..6974839 100644
--- a/src/highlight/GameOverlay.jsx
+++ b/src/highlight/GameOverlay.jsx
@@ -47,6 +47,24 @@ const QuickAction = ({ label, onClick, disabled }) => (
   </button>
 );
 
+const getBridgeShutdownUrl = () => {
+  if (typeof window === 'undefined') {
+    return 'http://127.0.0.1:5055/shutdown';
+  }
+  const stored =
+    window.localStorage.getItem('ha.ws.url') || 'ws://127.0.0.1:5055/ws';
+  try {
+    const url = new URL(stored);
+    url.protocol = url.protocol === 'wss:' ? 'https:' : 'http:';
+    url.pathname = '/shutdown';
+    url.search = '';
+    url.hash = '';
+    return url.toString();
+  } catch {
+    return 'http://127.0.0.1:5055/shutdown';
+  }
+};
+
 export default function GameOverlay({
   dashboardOpen,
   setDashboardOpen,
@@ -78,6 +96,8 @@ export default function GameOverlay({
         : 120,
     y: 72,
   }));
+  const [bridgeStatus, setBridgeStatus] = useState('');
+  const [bridgeBusy, setBridgeBusy] = useState(false);
 
   useEffect(() => {
     if (!dashboardOpen) {
@@ -261,7 +281,50 @@ export default function GameOverlay({
               onClick={handleSnapshot}
               disabled={!currentRect || savingSnapshot}
             />
+            <QuickAction
+              label={bridgeBusy ? 'Stopping…' : 'Stop Bridge'}
+              onClick={async () => {
+                if (bridgeBusy) {
+                  return;
+                }
+                setBridgeBusy(true);
+                setBridgeStatus('Stopping bridge…');
+                try {
+                  const url = getBridgeShutdownUrl();
+                  const token =
+                    (typeof window !== 'undefined' &&
+                      window.localStorage.getItem('ha.ws.token')) ||
+                    '';
+                  const response = await fetch(url, {
+                    method: 'POST',
+                    headers: token
+                      ? {
+                          'X-Bridge-Token': token,
+                        }
+                      : undefined,
+                  });
+                  const body = await response.json().catch(() => ({}));
+                  if (response.ok) {
+                    setBridgeStatus(
+                      body.message || 'Bridge shutting down shortly.'
+                    );
+                  } else {
+                    setBridgeStatus(
+                      body.error || `Bridge stop failed (status ${response.status})`
+                    );
+                  }
+                } catch (error) {
+                  setBridgeStatus(error.message || 'Unable to reach bridge.');
+                } finally {
+                  setBridgeBusy(false);
+                }
+              }}
+              disabled={bridgeBusy}
+            />
           </div>
+          {bridgeStatus && (
+            <div style={{ fontSize: 12, opacity: 0.75 }}>{bridgeStatus}</div>
+          )}
         </div>
       );
     }
@@ -366,6 +429,7 @@ export default function GameOverlay({
   return (
     <div
       ref={overlayRef}
+      data-ha-ui="true"
       style={{
         position: 'fixed',
         left: position.x,
diff --git a/src/highlight/HighlightAssistProvider.jsx b/src/highlight/HighlightAssistProvider.jsx
index f54e3c9..de128e1 100644
--- a/src/highlight/HighlightAssistProvider.jsx
+++ b/src/highlight/HighlightAssistProvider.jsx
@@ -7,6 +7,7 @@ import React, {
   useRef,
   useState,
 } from 'react';
+import { createPortal } from 'react-dom';
 import { useRafThrottle } from './useRafThrottle';
 import { getCssSelector } from './getCssSelector';
 import { injectHighlightStyles } from './injectStyles';
@@ -17,6 +18,42 @@ import { sendCommand } from './commandBus';
 import { clampOpacity, buildSurfaceColors } from './theme';
 
 const DEFAULT_COMMAND_ENDPOINT = 'http://127.0.0.1:5056/command';
+const UI_MASK_SELECTOR = '[data-ha-ui="true"]';
+const BRIDGE_START_COMMAND = 'cd tools/ws_bridge && ./run_bridge.sh';
+
+const isWithinHighlightUI = (node) => {
+  if (typeof document === 'undefined') {
+    return false;
+  }
+  let current =
+    node instanceof Element
+      ? node
+      : node && node.parentElement
+        ? node.parentElement
+        : null;
+  while (current) {
+    if (current.matches && current.matches(UI_MASK_SELECTOR)) {
+      return true;
+    }
+    current = current.parentElement;
+  }
+  return false;
+};
+
+const describeElement = (element) => {
+  if (!(element instanceof Element)) {
+    return '';
+  }
+  let label = element.tagName?.toLowerCase() || 'node';
+  if (element.id) {
+    label += `#${element.id}`;
+  }
+  const classList = Array.from(element.classList || []);
+  if (classList.length) {
+    label += `.${classList.slice(0, 2).join('.')}`;
+  }
+  return label;
+};
 
 const normalizeKey = (value) => {
   if (!value) {
@@ -31,6 +68,31 @@ const normalizeKey = (value) => {
 
 const HighlightContext = createContext(null);
 
+const HELP_POPOVER_WIDTH = 250;
+const HELP_POPOVER_HEIGHT = 220;
+const HELP_POPOVER_PADDING = 20;
+
+const computePopoverPosition = (anchor) => {
+  if (!anchor || typeof window === 'undefined') {
+    return null;
+  }
+  const viewportWidth = window.innerWidth;
+  const viewportHeight = window.innerHeight;
+  let top = anchor.bottom + 10;
+  if (top + HELP_POPOVER_HEIGHT > viewportHeight - HELP_POPOVER_PADDING) {
+    top = Math.max(HELP_POPOVER_PADDING, viewportHeight - HELP_POPOVER_HEIGHT - 10);
+  }
+  let left = anchor.right + 12;
+  if (left + HELP_POPOVER_WIDTH > viewportWidth - HELP_POPOVER_PADDING) {
+    left = anchor.left - HELP_POPOVER_WIDTH - 12;
+  }
+  left = Math.min(
+    Math.max(left, HELP_POPOVER_PADDING),
+    viewportWidth - HELP_POPOVER_WIDTH - HELP_POPOVER_PADDING
+  );
+  return { top, left };
+};
+
 export const useHighlightAssist = () => {
   const ctx = useContext(HighlightContext);
   if (!ctx) {
@@ -83,7 +145,6 @@ const useHighlightState = () => {
   const [overlayOpacity, setOverlayOpacity] = useState(() =>
     clampOpacity(parseFloat(storageGet('ha.overlay.opacity', '0.35')))
   );
-  const [showSettings, setShowSettings] = useState(false);
   const [dashboardHotkey, setDashboardHotkey] = useState(() =>
     normalizeKey(storageGet('ha.dashboard.hotkey', 'space'))
   );
@@ -109,6 +170,31 @@ const useHighlightState = () => {
   const [debugMode, setDebugMode] = useState(
     () => storageGet('ha.debug', 'false') === 'true' || debugQueryParam === '1'
   );
+  const [autoLockOnClick, setAutoLockOnClick] = useState(
+    () => storageGet('ha.autolock', 'true') !== 'false'
+  );
+  const [bridgeStatus, setBridgeStatus] = useState('');
+  const [bridgeStopping, setBridgeStopping] = useState(false);
+  const [bridgeHealthy, setBridgeHealthy] = useState(null);
+  const [bridgeChecking, setBridgeChecking] = useState(false);
+  const [bridgeLastCheck, setBridgeLastCheck] = useState(null);
+  const [bridgeError, setBridgeError] = useState(null);
+  const [bridgeMonitorEnabled, setBridgeMonitorEnabled] = useState(
+    () => storageGet('ha.bridge.monitor', 'false') === 'true'
+  );
+  const [bridgePanelOpen, setBridgePanelOpen] = useState(false);
+  const [bridgeWsUrl, setBridgeWsUrl] = useState(() =>
+    storageGet('ha.ws.url', 'ws://127.0.0.1:5055/ws')
+  );
+  const [bridgeToken, setBridgeToken] = useState(() =>
+    storageGet('ha.ws.token', 'dev-token-change-me')
+  );
+  const [layerInspectorOpen, setLayerInspectorOpen] = useState(false);
+  const [layerItems, setLayerItems] = useState([]);
+  const pointerRef = useRef({
+    x: typeof window !== 'undefined' ? window.innerWidth / 2 : 0,
+    y: typeof window !== 'undefined' ? window.innerHeight / 2 : 0,
+  });
   const [perfStats, setPerfStats] = useState({
     fps: 0,
     memory: null,
@@ -118,6 +204,57 @@ const useHighlightState = () => {
   const [savingSnapshot, setSavingSnapshot] = useState(false);
   const lastElementRef = useRef(null);
   const lockedObserverRef = useRef(null);
+  const hiddenLayerMapRef = useRef(new Map());
+  const [hiddenLayerSelectors, setHiddenLayerSelectors] = useState([]);
+  const autoLockReleaseRef = useRef(false);
+  const [helpBubble, setHelpBubble] = useState(null);
+  const tooltipTargetRef = useRef(null);
+  const tooltipTimerRef = useRef(null);
+  const tooltipPendingTextRef = useRef('');
+  const [tooltipState, setTooltipState] = useState({
+    message: '',
+    visible: false,
+    x: 0,
+    y: 0,
+  });
+  const clearTooltipTimer = useCallback(() => {
+    if (tooltipTimerRef.current) {
+      clearTimeout(tooltipTimerRef.current);
+      tooltipTimerRef.current = null;
+    }
+  }, []);
+  const showTooltip = useCallback((text) => {
+    if (typeof window === 'undefined' || !tooltipTargetRef.current) {
+      return;
+    }
+    const rect = tooltipTargetRef.current.getBoundingClientRect();
+    setTooltipState({
+      message: text,
+      visible: true,
+      x: rect.left + rect.width / 2,
+      y: rect.top - 12,
+    });
+  }, []);
+  const hideTooltip = useCallback(() => {
+    clearTooltipTimer();
+    tooltipPendingTextRef.current = '';
+    tooltipTargetRef.current = null;
+    setTooltipState((prev) =>
+      prev.visible
+        ? {
+            ...prev,
+            visible: false,
+            message: '',
+          }
+        : prev
+    );
+  }, [clearTooltipTimer]);
+  const openHelpBubble = useCallback((payload) => {
+    setHelpBubble(payload);
+  }, []);
+  const closeHelpBubble = useCallback(() => {
+    setHelpBubble(null);
+  }, []);
   const hasUndo = inspectionHistory.length > 0;
 
   const toggle = useCallback(() => setEnabled((value) => !value), []);
@@ -198,15 +335,334 @@ const useHighlightState = () => {
     }
   }, [currentRect]);
 
+  const resetHiddenLayers = useCallback(() => {
+    hiddenLayerMapRef.current.forEach((entry, element) => {
+      if (!element || !element.style) {
+        return;
+      }
+      const prevVisibility =
+        typeof entry?.visibility === 'string' ? entry.visibility : '';
+      element.style.visibility = prevVisibility;
+    });
+    hiddenLayerMapRef.current.clear();
+    setHiddenLayerSelectors([]);
+  }, []);
+
+  const toggleLayerVisibility = useCallback((element, selector) => {
+    if (!element || !selector) {
+      return;
+    }
+    setHiddenLayerSelectors((prev) => {
+      const isHidden = prev.includes(selector);
+      if (isHidden) {
+        const entry = hiddenLayerMapRef.current.get(element);
+        if (element.style) {
+          element.style.visibility =
+            entry && typeof entry.visibility === 'string'
+              ? entry.visibility
+              : '';
+        }
+        hiddenLayerMapRef.current.delete(element);
+        return prev.filter((value) => value !== selector);
+      }
+      hiddenLayerMapRef.current.set(element, {
+        visibility: element.style ? element.style.visibility || '' : '',
+        selector,
+      });
+      if (element.style) {
+        element.style.visibility = 'hidden';
+      }
+      return [...prev, selector];
+    });
+  }, []);
+
+  useEffect(
+    () => () => {
+      resetHiddenLayers();
+    },
+    [resetHiddenLayers]
+  );
+
+  useEffect(() => {
+    if (!layerInspectorOpen) {
+      resetHiddenLayers();
+    }
+  }, [layerInspectorOpen, resetHiddenLayers]);
+
+  useEffect(() => {
+    if (typeof window === 'undefined') {
+      return;
+    }
+    const handleMouseOver = (event) => {
+      if (!(event.target instanceof Element)) {
+        return;
+      }
+      const target = event.target.closest('[data-ha-tooltip]');
+      if (!target || !isWithinHighlightUI(target)) {
+        return;
+      }
+      if (tooltipTargetRef.current === target) {
+        return;
+      }
+      clearTooltipTimer();
+      tooltipTargetRef.current = target;
+      setTooltipState((prev) =>
+        prev.visible
+          ? {
+              ...prev,
+              visible: false,
+              message: '',
+            }
+          : prev
+      );
+      const nextText = target.getAttribute('data-ha-tooltip') || '';
+      if (!nextText) {
+        return;
+      }
+      tooltipPendingTextRef.current = nextText;
+      tooltipTimerRef.current = window.setTimeout(() => {
+        tooltipTimerRef.current = null;
+        if (!tooltipTargetRef.current) {
+          return;
+        }
+        showTooltip(tooltipPendingTextRef.current);
+      }, 2000);
+    };
+    const handleMouseOut = (event) => {
+      if (!tooltipTargetRef.current || !(event.target instanceof Element)) {
+        return;
+      }
+      if (!tooltipTargetRef.current.contains(event.target)) {
+        return;
+      }
+      const related =
+        event.relatedTarget instanceof Element
+          ? event.relatedTarget
+          : null;
+      if (related && tooltipTargetRef.current.contains(related)) {
+        return;
+      }
+      hideTooltip();
+    };
+    const handleCancel = () => {
+      hideTooltip();
+    };
+    document.addEventListener('mouseover', handleMouseOver, true);
+    document.addEventListener('mouseout', handleMouseOut, true);
+    document.addEventListener('mousedown', handleCancel, true);
+    document.addEventListener('keydown', handleCancel, true);
+    return () => {
+      document.removeEventListener('mouseover', handleMouseOver, true);
+      document.removeEventListener('mouseout', handleMouseOut, true);
+      document.removeEventListener('mousedown', handleCancel, true);
+      document.removeEventListener('keydown', handleCancel, true);
+    };
+  }, [clearTooltipTimer, hideTooltip, showTooltip]);
+
+  useEffect(() => {
+    if (!tooltipState.visible || typeof window === 'undefined') {
+      return;
+    }
+    const reposition = () => {
+      if (!tooltipTargetRef.current) {
+        setTooltipState((prev) =>
+          prev.visible
+            ? { ...prev, visible: false, message: '' }
+            : prev
+        );
+        return;
+      }
+      const rect = tooltipTargetRef.current.getBoundingClientRect();
+      setTooltipState((prev) =>
+        prev.visible
+          ? {
+              ...prev,
+              x: rect.left + rect.width / 2,
+              y: rect.top - 12,
+            }
+          : prev
+      );
+    };
+    window.addEventListener('scroll', reposition, true);
+    window.addEventListener('resize', reposition);
+    return () => {
+      window.removeEventListener('scroll', reposition, true);
+      window.removeEventListener('resize', reposition);
+    };
+  }, [tooltipState.visible]);
+
+  const withMaskedUI = useCallback((fn) => {
+    if (typeof document === 'undefined') {
+      return fn();
+    }
+    const overlays = Array.from(document.querySelectorAll(UI_MASK_SELECTOR));
+    const prev = overlays.map((node) => node.style.pointerEvents);
+    overlays.forEach((node) => {
+      node.style.pointerEvents = 'none';
+    });
+    const result = fn();
+    overlays.forEach((node, idx) => {
+      node.style.pointerEvents = prev[idx];
+    });
+    return result;
+  }, []);
+
+  const sampleElementsAtPoint = useCallback(
+    (clientX, clientY) => {
+      if (typeof document === 'undefined') {
+        return [];
+      }
+      return withMaskedUI(() =>
+        (document.elementsFromPoint(clientX, clientY) || []).filter(
+          (node) =>
+            node instanceof Element && !node.closest(UI_MASK_SELECTOR)
+        )
+      );
+    },
+    [withMaskedUI]
+  );
+
+  const captureLayerPreview = useCallback((element) => {
+    if (typeof window === 'undefined' || !element) {
+      return {
+        background: 'rgba(30,41,59,0.6)',
+        borderRadius: '8px',
+        hasImage: false,
+      };
+    }
+    try {
+      const styles = window.getComputedStyle(element);
+      const backgroundColor = styles.backgroundColor;
+      const borderRadius = styles.borderRadius || '8px';
+      const hasImage =
+        (styles.backgroundImage && styles.backgroundImage !== 'none') ||
+        element.tagName === 'IMG' ||
+        element.tagName === 'VIDEO';
+      const fallback =
+        backgroundColor && backgroundColor !== 'rgba(0, 0, 0, 0)'
+          ? backgroundColor
+          : 'rgba(30,41,59,0.65)';
+      return {
+        background: fallback,
+        borderRadius,
+        hasImage,
+      };
+    } catch {
+      return {
+        background: 'rgba(30,41,59,0.6)',
+        borderRadius: '8px',
+        hasImage: false,
+      };
+    }
+  }, []);
+
+  const refreshLayerInspector = useCallback(
+    (clientX, clientY, options = {}) => {
+      if (!layerInspectorOpen && !options.force) {
+        return;
+      }
+      const x = clientX ?? pointerRef.current.x;
+      const y = clientY ?? pointerRef.current.y;
+      const elements = sampleElementsAtPoint(x, y);
+      const mapped = elements.slice(0, 8).map((element) => ({
+        element,
+        selector: getCssSelector(element),
+        label: describeElement(element),
+        rect: element.getBoundingClientRect(),
+        preview: captureLayerPreview(element),
+      }));
+      const activeSelectors = new Set(mapped.map((item) => item.selector));
+      hiddenLayerMapRef.current.forEach((entry, element) => {
+        if (!entry || !activeSelectors.has(entry.selector)) {
+          if (element && element.style) {
+            element.style.visibility =
+              typeof entry?.visibility === 'string' ? entry.visibility : '';
+          }
+          hiddenLayerMapRef.current.delete(element);
+        }
+      });
+      setHiddenLayerSelectors((prev) =>
+        prev.filter((selector) => activeSelectors.has(selector))
+      );
+      setLayerItems(mapped);
+    },
+    [captureLayerPreview, layerInspectorOpen, sampleElementsAtPoint]
+  );
+
+  const lockElementTarget = useCallback(
+    (element) => {
+      if (
+        !element ||
+        !(element instanceof Element) ||
+        element === document.body ||
+        element === document.documentElement
+      ) {
+        return;
+      }
+
+      setInspectionHistory((prev) => {
+        if (currentRect && currentSelector) {
+          return [
+            ...prev,
+            {
+              rect: {
+                left: currentRect.left,
+                top: currentRect.top,
+                width: currentRect.width,
+                height: currentRect.height,
+              },
+              selector: currentSelector,
+              snippet: currentSnippet,
+            },
+          ].slice(-20);
+        }
+        return prev;
+      });
+
+      const selector = getCssSelector(element);
+      const rect = element.getBoundingClientRect();
+      lastElementRef.current = element;
+      setCurrentRect(rect);
+      setCurrentSelector(selector);
+      setCurrentSnippet(element.textContent?.trim().slice(0, 220) ?? '');
+      setLocked(true);
+      lockedObserverRef.current?.disconnect();
+      if (typeof ResizeObserver !== 'undefined') {
+        const observer = new ResizeObserver(() => {
+          if (!lastElementRef.current) {
+            return;
+          }
+          setCurrentRect(lastElementRef.current.getBoundingClientRect());
+        });
+        observer.observe(element);
+        lockedObserverRef.current = observer;
+      }
+      const centerX = rect.left + rect.width / 2;
+      const centerY = rect.top + rect.height / 2;
+      pointerRef.current = { x: centerX, y: centerY };
+      if (layerInspectorOpen) {
+        refreshLayerInspector(centerX, centerY, { force: true });
+      }
+      autoLockReleaseRef.current = true;
+    },
+    [
+      currentRect,
+      currentSelector,
+      currentSnippet,
+      layerInspectorOpen,
+      refreshLayerInspector,
+    ]
+  );
+
   const resetHighlight = useCallback(() => {
     setEnabled(false);
     setDashboardOpen(false);
-    setShowSettings(false);
     setComposerDraft(null);
     setLocked(false);
     setCurrentRect(null);
     setCurrentSelector(null);
     setCurrentSnippet('');
+    autoLockReleaseRef.current = false;
   }, []);
 
   const openComposer = useCallback(
@@ -233,6 +689,18 @@ const useHighlightState = () => {
     storageSet('ha.debug', debugMode ? 'true' : 'false');
   }, [debugMode]);
 
+  useEffect(() => {
+    storageSet('ha.bridge.monitor', bridgeMonitorEnabled ? 'true' : 'false');
+  }, [bridgeMonitorEnabled]);
+
+  useEffect(() => {
+    storageSet('ha.ws.url', bridgeWsUrl);
+  }, [bridgeWsUrl]);
+
+  useEffect(() => {
+    storageSet('ha.ws.token', bridgeToken);
+  }, [bridgeToken]);
+
   const debugLog = useCallback(
     (...args) => {
       if (!debugMode) {
@@ -244,6 +712,192 @@ const useHighlightState = () => {
     [debugMode]
   );
 
+  useEffect(() => {
+    storageSet('ha.autolock', autoLockOnClick ? 'true' : 'false');
+  }, [autoLockOnClick]);
+
+  const copySelector = useCallback(
+    async (selectorValue) => {
+      if (!selectorValue || typeof navigator === 'undefined') {
+        return;
+      }
+      try {
+        await navigator.clipboard.writeText(selectorValue);
+      } catch (error) {
+        debugLog('clipboard copy failed', error);
+      }
+    },
+    [debugLog]
+  );
+
+  const copyBridgeCommand = useCallback(async () => {
+    if (typeof navigator === 'undefined') {
+      return;
+    }
+    try {
+      await navigator.clipboard.writeText(BRIDGE_START_COMMAND);
+      setBridgeStatus('Launch command copied');
+      setTimeout(() => setBridgeStatus(''), 1500);
+    } catch (error) {
+      debugLog('copy bridge command failed', error);
+    }
+  }, [debugLog]);
+
+  const copyBridgeUrl = useCallback(async () => {
+    if (typeof navigator === 'undefined') {
+      return;
+    }
+    try {
+      await navigator.clipboard.writeText(bridgeWsUrl);
+      setBridgeStatus('WS URL copied');
+      setTimeout(() => setBridgeStatus(''), 1500);
+    } catch (error) {
+      debugLog('copy bridge url failed', error);
+    }
+  }, [bridgeWsUrl, debugLog]);
+
+  const copyBridgeToken = useCallback(async () => {
+    if (typeof navigator === 'undefined') {
+      return;
+    }
+    try {
+      await navigator.clipboard.writeText(bridgeToken || '');
+      setBridgeStatus('Bridge token copied');
+      setTimeout(() => setBridgeStatus(''), 1500);
+    } catch (error) {
+      debugLog('copy bridge token failed', error);
+    }
+  }, [bridgeToken, debugLog]);
+
+  const getBridgeHttpBase = useCallback(() => {
+    const stored = bridgeWsUrl || 'ws://127.0.0.1:5055/ws';
+    try {
+      const parsed = new URL(stored || 'ws://127.0.0.1:5055/ws');
+      parsed.protocol = parsed.protocol === 'wss:' ? 'https:' : 'http:';
+      parsed.pathname = '';
+      parsed.search = '';
+      parsed.hash = '';
+      const str = parsed.toString();
+      return str.endsWith('/') ? str.slice(0, -1) : str;
+    } catch {
+      return 'http://127.0.0.1:5055';
+    }
+  }, [bridgeWsUrl]);
+
+  const getBridgeShutdownUrl = useCallback(() => {
+    const base = getBridgeHttpBase();
+    return `${base}/shutdown`;
+  }, [getBridgeHttpBase]);
+
+  const openBridgeHealth = useCallback(() => {
+    if (typeof window === 'undefined') {
+      return;
+    }
+    const url = `${getBridgeHttpBase()}/health`;
+    window.open(url, '_blank', 'noopener,noreferrer');
+  }, [getBridgeHttpBase]);
+
+  const stopBridge = useCallback(async () => {
+    if (bridgeStopping) {
+      return;
+    }
+    if (typeof fetch === 'undefined') {
+      return;
+    }
+    setBridgeStopping(true);
+    setBridgeStatus('Stopping bridge…');
+    try {
+      const shutdownUrl = getBridgeShutdownUrl();
+      const tokenHeader = bridgeToken || 'dev-token-change-me';
+      const response = await fetch(shutdownUrl, {
+        method: 'POST',
+        headers: {
+          'X-Bridge-Token': tokenHeader,
+        },
+      });
+      const body = await response.json().catch(() => ({}));
+      if (response.ok) {
+        setBridgeStatus(body.message || 'Bridge shutting down.');
+      } else {
+        setBridgeStatus(
+          body.error || `Bridge stop failed (status ${response.status})`
+        );
+      }
+    } catch (error) {
+      setBridgeStatus(error.message || 'Unable to reach bridge.');
+    } finally {
+      setBridgeStopping(false);
+    }
+  }, [bridgeStopping, bridgeToken, getBridgeShutdownUrl]);
+
+  const refreshBridgeHealth = useCallback(
+    async ({ quiet } = {}) => {
+      if (typeof fetch === 'undefined') {
+        return;
+      }
+      if (!quiet) {
+        setBridgeChecking(true);
+      }
+      try {
+        const response = await fetch(`${getBridgeHttpBase()}/health`, {
+          method: 'GET',
+          cache: 'no-store',
+          mode: 'no-cors',
+        });
+        const ok = response.type === 'opaque' || response.ok;
+        setBridgeHealthy(ok);
+        setBridgeLastCheck(new Date().toISOString());
+        setBridgeError(
+          ok || response.type === 'opaque'
+            ? null
+            : `Health responded with ${response.status}`
+        );
+      } catch (error) {
+        setBridgeHealthy(false);
+        setBridgeError(error.message || 'Unable to reach bridge');
+        setBridgeLastCheck(new Date().toISOString());
+      } finally {
+        if (!quiet) {
+          setBridgeChecking(false);
+        }
+      }
+    },
+    [getBridgeHttpBase]
+  );
+
+  useEffect(() => {
+    if (!bridgeMonitorEnabled || typeof fetch === 'undefined') {
+      return undefined;
+    }
+    let active = true;
+    const run = async () => {
+      if (!active) {
+        return;
+      }
+      await refreshBridgeHealth({ quiet: true });
+    };
+    run();
+    const id = setInterval(run, 5000);
+    return () => {
+      active = false;
+      clearInterval(id);
+    };
+  }, [bridgeMonitorEnabled, refreshBridgeHealth]);
+
+  const getInspectableElement = useCallback(
+    (clientX, clientY) => {
+      if (typeof document === 'undefined') {
+        return null;
+      }
+
+      return withMaskedUI(() => {
+        const target = document.elementFromPoint(clientX, clientY);
+        return target instanceof Element ? target : null;
+      });
+    },
+    [withMaskedUI]
+  );
+
   useEffect(() => {
     storageSet('ha.dashboard.hotkey', dashboardHotkey);
   }, [dashboardHotkey]);
@@ -276,33 +930,51 @@ const useHighlightState = () => {
   }, []);
 
   const onMove = useRafThrottle((event) => {
-    if (typeof document === 'undefined' || !enabled || locked) {
+    if (event.target && isWithinHighlightUI(event.target)) {
+      return;
+    }
+
+    pointerRef.current = { x: event.clientX, y: event.clientY };
+    refreshLayerInspector(event.clientX, event.clientY);
+
+    if (!enabled) {
       return;
     }
 
-    const hovered = document.elementFromPoint(event.clientX, event.clientY);
+    const hovered = getInspectableElement(event.clientX, event.clientY);
     if (
       !hovered ||
       hovered === document.documentElement ||
       hovered === document.body
     ) {
-      setCurrentRect(null);
-      setCurrentSelector(null);
-      setCurrentSnippet('');
-      lastElementRef.current = null;
+      if (!locked) {
+        setCurrentRect(null);
+        setCurrentSelector(null);
+        setCurrentSnippet('');
+        lastElementRef.current = null;
+      }
+      return;
+    }
+
+    if (locked && lastElementRef.current === hovered) {
+      try {
+        setCurrentRect(hovered.getBoundingClientRect());
+      } catch (error) {
+        debugLog('failed to inspect element', error);
+      }
+      return;
+    }
+
+    if (locked) {
       return;
     }
 
     try {
       const rect = hovered.getBoundingClientRect();
-      if (lastElementRef.current !== hovered) {
-        lastElementRef.current = hovered;
-        setCurrentRect(rect);
-        setCurrentSelector(getCssSelector(hovered));
-        setCurrentSnippet(hovered.textContent?.trim().slice(0, 220) ?? '');
-      } else {
-        setCurrentRect(rect);
-      }
+      lastElementRef.current = hovered;
+      setCurrentRect(rect);
+      setCurrentSelector(getCssSelector(hovered));
+      setCurrentSnippet(hovered.textContent?.trim().slice(0, 220) ?? '');
     } catch (error) {
       debugLog('failed to inspect element', error);
     }
@@ -358,6 +1030,7 @@ const useHighlightState = () => {
       setCurrentRect(null);
       setCurrentSelector(null);
       setCurrentSnippet('');
+      autoLockReleaseRef.current = false;
       lastElementRef.current = null;
       lockedObserverRef.current?.disconnect();
     }
@@ -372,71 +1045,76 @@ const useHighlightState = () => {
       return undefined;
     }
 
-    const handleCtrlClick = (event) => {
-      if (!(event.ctrlKey || event.metaKey) || event.button !== 0) {
+    const handleClick = (event) => {
+      if (event.button !== 0) {
         return;
       }
 
-      const target = event.target;
-      if (!(target instanceof Element)) {
+      if (isWithinHighlightUI(event.target)) {
         return;
       }
 
-      event.preventDefault();
-      event.stopPropagation();
+      const wantsComposer = event.ctrlKey || event.metaKey;
+      const wantsAuto = autoLockOnClick && !wantsComposer;
 
-      try {
-        setInspectionHistory((prev) => {
-          if (!currentRect || !currentSelector) {
-            return prev;
-          }
-          const snapshot = {
-            rect: {
-              left: currentRect.left,
-              top: currentRect.top,
-              width: currentRect.width,
-              height: currentRect.height,
-            },
-            selector: currentSelector,
-            snippet: currentSnippet,
-          };
-          return [...prev, snapshot].slice(-20);
-        });
-        const selector = getCssSelector(target);
-        const rect = target.getBoundingClientRect();
-        lastElementRef.current = target;
-        setCurrentRect(rect);
-        setCurrentSelector(selector);
-        setCurrentSnippet(
-          target.textContent?.trim().slice(0, 220) ?? currentSnippet
-        );
-        setLocked(true);
+      if (!wantsComposer && !wantsAuto) {
+        return;
+      }
+
+      const target = getInspectableElement(event.clientX, event.clientY);
+      const unlockCurrent = () => {
+        setLocked(false);
+        setCurrentRect(null);
+        setCurrentSelector(null);
+        setCurrentSnippet('');
+        lastElementRef.current = null;
         lockedObserverRef.current?.disconnect();
-        if (typeof ResizeObserver !== 'undefined') {
-          const observer = new ResizeObserver(() => {
-            if (!lastElementRef.current) {
-              return;
-            }
-            setCurrentRect(lastElementRef.current.getBoundingClientRect());
-          });
-          observer.observe(target);
-          lockedObserverRef.current = observer;
+        autoLockReleaseRef.current = false;
+      };
+
+      if (!target) {
+        if (autoLockOnClick && !wantsComposer) {
+          unlockCurrent();
         }
+        return;
+      }
 
-      openComposer({
-        selector,
-        snippet: target.textContent?.trim().slice(0, 220) ?? '',
-        clientX: event.clientX,
-        clientY: event.clientY,
-      });
-      } catch (error) {
-        debugLog('ctrl-click failed', error);
+      if (
+        wantsAuto &&
+        locked &&
+        autoLockReleaseRef.current &&
+        lastElementRef.current === target &&
+        !wantsComposer
+      ) {
+        unlockCurrent();
+        return;
+      }
+
+      event.preventDefault();
+      event.stopPropagation();
+
+      lockElementTarget(target);
+      autoLockReleaseRef.current = wantsAuto;
+
+      if (wantsComposer) {
+        openComposer({
+          selector: getCssSelector(target),
+          snippet: target.textContent?.trim().slice(0, 220) ?? '',
+          clientX: event.clientX,
+          clientY: event.clientY,
+        });
       }
     };
 
-    document.addEventListener('click', handleCtrlClick, true);
-    return () => document.removeEventListener('click', handleCtrlClick, true);
-  }, [enabled, openComposer, currentRect, currentSelector, currentSnippet]);
+    document.addEventListener('click', handleClick, true);
+    return () => document.removeEventListener('click', handleClick, true);
+  }, [
+    enabled,
+    autoLockOnClick,
+    getInspectableElement,
+    lockElementTarget,
+    openComposer,
+  ]);
 
   const contextValue = useMemo(
     () => ({
@@ -456,8 +1134,6 @@ const useHighlightState = () => {
       setCommandEndpoint,
       overlayOpacity,
       setOverlayOpacity,
-      showSettings,
-      setShowSettings,
       dashboardOpen,
       setDashboardOpen,
       commandHistory,
@@ -473,6 +1149,41 @@ const useHighlightState = () => {
       debugMode,
       setDebugMode,
       debugLog,
+      autoLockOnClick,
+      setAutoLockOnClick,
+      bridgeStatus,
+      bridgeStopping,
+      stopBridge,
+      bridgeHealthy,
+      bridgeChecking,
+      bridgeLastCheck,
+      bridgeError,
+      refreshBridgeHealth,
+      bridgeMonitorEnabled,
+      setBridgeMonitorEnabled,
+      bridgePanelOpen,
+      setBridgePanelOpen,
+      bridgeWsUrl,
+      setBridgeWsUrl,
+      bridgeToken,
+      setBridgeToken,
+      copyBridgeCommand,
+      copyBridgeUrl,
+      copyBridgeToken,
+      openBridgeHealth,
+      layerInspectorOpen,
+      setLayerInspectorOpen,
+      layerItems,
+      refreshLayerInspector,
+      lockElementTarget,
+      copySelector,
+      hiddenLayerSelectors,
+      toggleLayerVisibility,
+      resetHiddenLayers,
+      tooltipState,
+      helpBubble,
+      openHelpBubble,
+      closeHelpBubble,
     }),
     [
       enabled,
@@ -491,8 +1202,6 @@ const useHighlightState = () => {
       setCommandEndpoint,
       overlayOpacity,
       setOverlayOpacity,
-      showSettings,
-      setShowSettings,
       dashboardOpen,
       setDashboardOpen,
       commandHistory,
@@ -508,6 +1217,41 @@ const useHighlightState = () => {
       debugMode,
       setDebugMode,
       debugLog,
+      autoLockOnClick,
+      setAutoLockOnClick,
+      bridgeStatus,
+      bridgeStopping,
+      stopBridge,
+      bridgeHealthy,
+      bridgeChecking,
+      bridgeLastCheck,
+      bridgeError,
+      refreshBridgeHealth,
+      bridgeMonitorEnabled,
+      setBridgeMonitorEnabled,
+      bridgePanelOpen,
+      setBridgePanelOpen,
+      bridgeWsUrl,
+      setBridgeWsUrl,
+      bridgeToken,
+      setBridgeToken,
+      copyBridgeCommand,
+      copyBridgeUrl,
+      copyBridgeToken,
+      openBridgeHealth,
+      layerInspectorOpen,
+      setLayerInspectorOpen,
+      layerItems,
+      refreshLayerInspector,
+      lockElementTarget,
+      copySelector,
+      hiddenLayerSelectors,
+      toggleLayerVisibility,
+      resetHiddenLayers,
+      tooltipState,
+      helpBubble,
+      openHelpBubble,
+      closeHelpBubble,
     ]
   );
 
@@ -526,6 +1270,22 @@ const useHighlightState = () => {
     handleSnapshot,
     savingSnapshot,
     debugMode,
+    autoLockOnClick,
+    setAutoLockOnClick,
+    bridgeStatus,
+    bridgeStopping,
+    stopBridge,
+    bridgeHealthy,
+    bridgeChecking,
+    bridgeLastCheck,
+    bridgeError,
+    refreshBridgeHealth,
+    bridgeMonitorEnabled,
+    setBridgeMonitorEnabled,
+    bridgePanelOpen,
+    setBridgePanelOpen,
+    bridgeWsUrl,
+    setBridgeWsUrl,
   };
 };
 
@@ -556,6 +1316,19 @@ const Overlay = ({ rect, enabled, overlayOpacity }) => {
 };
 
 const Panel = () => {
+  const PANEL_RESIZE_HANDLES = useMemo(
+    () => [
+      'top-left',
+      'top',
+      'top-right',
+      'right',
+      'bottom-right',
+      'bottom',
+      'bottom-left',
+      'left',
+    ],
+    []
+  );
   const {
     enabled,
     setEnabled,
@@ -570,8 +1343,6 @@ const Panel = () => {
     setCommandEndpoint,
     overlayOpacity,
     setOverlayOpacity,
-    showSettings,
-    setShowSettings,
     setDashboardOpen,
     dashboardHotkey,
     setDashboardHotkey,
@@ -581,37 +1352,1427 @@ const Panel = () => {
     savingSnapshot,
     debugMode,
     setDebugMode,
+    debugLog,
+    autoLockOnClick,
+    setAutoLockOnClick,
+    bridgeStatus,
+    bridgeStopping,
+    stopBridge,
+    bridgeHealthy,
+    bridgeChecking,
+    bridgeLastCheck,
+    bridgeError,
+    refreshBridgeHealth,
+    bridgeMonitorEnabled,
+    setBridgeMonitorEnabled,
+    bridgePanelOpen,
+    setBridgePanelOpen,
+    bridgeWsUrl,
+    setBridgeWsUrl,
+    bridgeToken,
+    setBridgeToken,
+    copyBridgeCommand,
+    copyBridgeUrl,
+    copyBridgeToken,
+    openBridgeHealth,
+    layerInspectorOpen,
+    setLayerInspectorOpen,
+    refreshLayerInspector,
+    lockElementTarget,
+    copySelector,
+    resetHiddenLayers,
+    openHelpBubble,
   } = useHighlightAssist();
 
   const [hidden, setHidden] = useState(false);
+  const [activeTab, setActiveTab] = useState('controls');
+  const initialViewportHeight =
+    typeof window !== 'undefined' ? window.innerHeight : 900;
+  const [viewportHeight, setViewportHeight] = useState(
+    initialViewportHeight
+  );
+  const [panelSize, setPanelSize] = useState(() => ({
+    width: 280,
+    height: Math.max(360, Math.min(580, initialViewportHeight - 64)),
+  }));
   const panelRef = useRef(null);
   const dragRef = useRef(null);
+  const resizeDragRef = useRef(null);
   const positionRef = useRef({ x: 24, y: 24 });
+  const [panelIsMaximized, setPanelIsMaximized] = useState(false);
+  const panelIsMaximizedRef = useRef(panelIsMaximized);
+  const panelRestoreStateRef = useRef({
+    size: { width: panelSize.width, height: panelSize.height },
+    position: { ...positionRef.current },
+  });
+  const panelSizeRef = useRef(panelSize);
+  const viewportHeightRef = useRef(viewportHeight);
+  const renderSection = (title, children) => (
+    <div className="ha-panel-section">
+      <div className="ha-panel-section-title">{title}</div>
+      <div className="ha-section-grid">{children}</div>
+    </div>
+  );
   const surfaces = buildSurfaceColors(overlayOpacity);
   const panelBackground = surfaces.panel;
   const borderColor = surfaces.border;
   const inputBackground = surfaces.input;
   const panelShadow = surfaces.shadow;
   const baseOpacity = surfaces.base;
+  const clamp = useCallback(
+    (value, min, max) => Math.min(max, Math.max(min, value)),
+    []
+  );
+  const updatePanelTransform = useCallback((next) => {
+    positionRef.current = next;
+    if (panelRef.current) {
+      panelRef.current.style.transform = `translate(${next.x}px, ${next.y}px)`;
+    }
+  }, []);
+
+  useEffect(() => {
+    panelSizeRef.current = panelSize;
+  }, [panelSize]);
+
+  useEffect(() => {
+    updatePanelTransform(positionRef.current);
+  }, [updatePanelTransform]);
+
+  const handlePanelMaxToggle = useCallback(() => {
+    if (typeof window === 'undefined') {
+      return;
+    }
+    if (!panelIsMaximizedRef.current) {
+      panelRestoreStateRef.current = {
+        size: { ...panelSizeRef.current },
+        position: { ...positionRef.current },
+      };
+      const maxWidth = Math.min(
+        Math.max(panelSizeRef.current.width, 320),
+        window.innerWidth - 32
+      );
+      const maxHeight = Math.max(360, window.innerHeight - 64);
+      setPanelSize({
+        width: maxWidth,
+        height: clamp(maxHeight, 360, window.innerHeight - 32),
+      });
+      updatePanelTransform({ x: 16, y: 16 });
+      setPanelIsMaximized(true);
+    } else {
+      if (panelRestoreStateRef.current?.size) {
+        setPanelSize(panelRestoreStateRef.current.size);
+      }
+      if (panelRestoreStateRef.current?.position) {
+        updatePanelTransform(panelRestoreStateRef.current.position);
+      }
+      setPanelIsMaximized(false);
+    }
+  }, [clamp, updatePanelTransform]);
+
+  const startPanelResize = useCallback((type, clientX, clientY) => {
+    resizeDragRef.current = {
+      type,
+      startX: clientX,
+      startY: clientY,
+      width: panelSizeRef.current.width,
+      height: panelSizeRef.current.height,
+      x: positionRef.current.x,
+      y: positionRef.current.y,
+    };
+  }, []);
+
+  const applyPanelResize = useCallback(
+    (clientX, clientY) => {
+      const state = resizeDragRef.current;
+      if (!state) {
+        return;
+      }
+      const dx = clientX - state.startX;
+      const dy = clientY - state.startY;
+      const minWidth = 260;
+      const maxWidth =
+        typeof window !== 'undefined'
+          ? Math.max(minWidth, window.innerWidth - 80)
+          : 520;
+      const minHeight = 320;
+      const maxHeight = Math.max(minHeight, viewportHeightRef.current - 32);
+
+      let nextWidth = state.width;
+      let nextHeight = state.height;
+      let nextX = state.x;
+      let nextY = state.y;
+
+      const includes = (segment) => state.type.includes(segment);
+
+      if (state.type === 'right' || includes('right')) {
+        nextWidth = clamp(state.width + dx, minWidth, maxWidth);
+      }
+
+      if (state.type === 'left' || includes('left')) {
+        const candidate = clamp(state.width - dx, minWidth, maxWidth);
+        const widthDelta = state.width - candidate;
+        nextWidth = candidate;
+        nextX = state.x + widthDelta;
+      }
+
+      if (state.type === 'bottom' || includes('bottom')) {
+        nextHeight = clamp(state.height + dy, minHeight, maxHeight);
+      }
+
+      if (state.type === 'top' || includes('top')) {
+        const candidate = clamp(state.height - dy, minHeight, maxHeight);
+        const heightDelta = state.height - candidate;
+        nextHeight = candidate;
+        nextY = state.y + heightDelta;
+      }
+
+      setPanelSize((prev) => {
+        if (prev.width === nextWidth && prev.height === nextHeight) {
+          return prev;
+        }
+        return { width: nextWidth, height: nextHeight };
+      });
+      if (nextX !== positionRef.current.x || nextY !== positionRef.current.y) {
+        updatePanelTransform({ x: nextX, y: nextY });
+      }
+    },
+    [clamp, updatePanelTransform]
+  );
 
   useEffect(() => {
-    if (!panelRef.current) {
+    if (typeof window === 'undefined') {
       return;
     }
-    const { x, y } = positionRef.current;
-    panelRef.current.style.transform = `translate(${x}px, ${y}px)`;
+    const handleResize = () => setViewportHeight(window.innerHeight);
+    window.addEventListener('resize', handleResize);
+    return () => window.removeEventListener('resize', handleResize);
   }, []);
 
   useEffect(() => {
-    if (typeof window === 'undefined') {
+    viewportHeightRef.current = viewportHeight;
+    const minHeight = 360;
+    const maxHeight = Math.max(minHeight, viewportHeight - 48);
+    setPanelSize((prev) => {
+      if (panelIsMaximized) {
+        const nextWidth =
+          typeof window !== 'undefined'
+            ? Math.min(Math.max(prev.width, 260), window.innerWidth - 32)
+            : prev.width;
+        return { width: nextWidth, height: maxHeight };
+      }
+      if (prev.height <= maxHeight) {
+        return prev;
+      }
+      return { ...prev, height: maxHeight };
+    });
+  }, [panelIsMaximized, viewportHeight]);
+
+  useEffect(() => {
+    if (!panelIsMaximized) {
+      panelRestoreStateRef.current = {
+        size: { width: panelSize.width, height: panelSize.height },
+        position: { ...positionRef.current },
+      };
+    }
+  }, [panelIsMaximized, panelSize]);
+
+  useEffect(() => {
+    panelIsMaximizedRef.current = panelIsMaximized;
+  }, [panelIsMaximized]);
+
+  useEffect(() => {
+    if (typeof window === 'undefined') {
+      return;
+    }
+
+    const handleDown = (event) => {
+      if (!panelRef.current) {
+        return;
+      }
+      const root = panelRef.current;
+      if (!root.contains(event.target)) {
+        return;
+      }
+      const resizeTarget = event.target.closest('[data-panel-resize]');
+      if (resizeTarget && root.contains(resizeTarget)) {
+        setPanelIsMaximized(false);
+        const handle = resizeTarget.getAttribute('data-panel-resize');
+        if (handle) {
+          startPanelResize(handle, event.clientX, event.clientY);
+        }
+        event.preventDefault();
+        return;
+      }
+      const dragHandle = event.target.closest('.ha-drag-handle');
+      if (!dragHandle || !root.contains(dragHandle)) {
+        return;
+      }
+      if (panelIsMaximizedRef.current) {
+        setPanelIsMaximized(false);
+        if (panelRestoreStateRef.current?.size) {
+          setPanelSize(panelRestoreStateRef.current.size);
+        }
+      }
+      dragRef.current = {
+        dx: event.clientX - positionRef.current.x,
+        dy: event.clientY - positionRef.current.y,
+      };
+      event.preventDefault();
+    };
+
+    const handleMove = (event) => {
+      if (resizeDragRef.current) {
+        applyPanelResize(event.clientX, event.clientY);
+        return;
+      }
+      if (!dragRef.current || !panelRef.current) {
+        return;
+      }
+
+      const next = {
+        x: event.clientX - dragRef.current.dx,
+        y: event.clientY - dragRef.current.dy,
+      };
+
+      updatePanelTransform(next);
+    };
+
+    const handleUp = () => {
+      dragRef.current = null;
+      resizeDragRef.current = null;
+    };
+
+    window.addEventListener('mousedown', handleDown);
+    window.addEventListener('mousemove', handleMove);
+    window.addEventListener('mouseup', handleUp);
+
+    return () => {
+      window.removeEventListener('mousedown', handleDown);
+      window.removeEventListener('mousemove', handleMove);
+      window.removeEventListener('mouseup', handleUp);
+    };
+  }, []);
+
+  if (hidden) {
+    return (
+      <div
+        ref={panelRef}
+        className="ha-panel"
+        data-ha-ui="true"
+        style={{
+          width: 'auto',
+          padding: '6px 10px',
+          display: 'inline-flex',
+          alignItems: 'center',
+          gap: '8px',
+          background: panelBackground,
+          border: `1px solid ${borderColor}`,
+        }}
+      >
+        <span style={{ fontSize: '12px' }}>Highlight Assist hidden</span>
+        <button
+          type="button"
+          className="ha-btn"
+          style={{ width: 'auto' }}
+          onClick={() => setHidden(false)}
+          data-ha-tooltip="Show the Highlight Assist controls again"
+        >
+          Show
+        </button>
+      </div>
+    );
+  }
+
+  const panelMaxHeight = Math.min(
+    Math.max(360, panelSize.height),
+    Math.max(360, viewportHeight - 48)
+  );
+  const panelBodyMaxHeight = Math.max(160, panelMaxHeight - 84);
+
+  const renderControls = () => (
+    <>
+      {renderSection(
+        'Inspector Controls',
+        <>
+          <button
+            className="ha-btn ha-section-grid-wide"
+            type="button"
+            onClick={() => setEnabled(!enabled)}
+            aria-pressed={enabled}
+            data-ha-tooltip="Toggle the inspector overlay (Ctrl/Cmd+Shift+H)"
+          >
+            {enabled
+              ? 'Disable (Ctrl/Cmd+Shift+H)'
+              : 'Enable (Ctrl/Cmd+Shift+H)'}
+          </button>
+          <button
+            className="ha-btn ha-ghost"
+            type="button"
+            onClick={() => lock(!locked)}
+            disabled={!enabled}
+            data-ha-tooltip="Freeze the current element so hover updates stop"
+          >
+            {locked ? 'Unlock Element' : 'Lock Element'}
+          </button>
+          <button
+            className="ha-btn ha-ghost"
+            type="button"
+            onClick={() => copySelector(currentSelector)}
+            disabled={!currentSelector}
+            data-ha-tooltip="Copy a unique selector for the active element"
+          >
+            Copy Selector
+          </button>
+          <button
+            className="ha-btn ha-ghost"
+            type="button"
+            onClick={() => setShowGrid(!showGrid)}
+            data-ha-tooltip="Toggle the baseline/grid overlay for alignment checks"
+          >
+            {showGrid ? 'Hide Grid' : 'Show Grid'}
+          </button>
+          <button
+            className="ha-btn ha-ghost"
+            type="button"
+            onClick={() => setDashboardOpen(true)}
+            data-ha-tooltip="Open the developer overlay dashboard"
+          >
+            Open Dev Overlay
+          </button>
+          <button
+            className="ha-btn"
+            type="button"
+            onClick={() =>
+              openComposer({
+                selector: currentSelector ?? '',
+                snippet: '',
+              })
+            }
+            disabled={!currentSelector}
+            data-ha-tooltip="Draft a bridge command using this element context"
+          >
+            Compose Command
+          </button>
+        </>
+      )}
+      {renderSection(
+        'History & Capture',
+        <>
+          <button
+            className="ha-btn ha-ghost"
+            type="button"
+            onClick={handleUndoInspect}
+            disabled={!hasUndo}
+            data-ha-tooltip="Step back to the previous inspected element"
+          >
+            Undo Inspect
+          </button>
+          <button
+            className="ha-btn ha-ghost"
+            type="button"
+            onClick={handleSnapshot}
+            disabled={!currentRect || savingSnapshot}
+            data-ha-tooltip="Capture a screenshot of the locked element"
+          >
+            {savingSnapshot ? 'Saving…' : 'Save Snapshot'}
+          </button>
+        </>
+      )}
+      {bridgeStatus && (
+        <div className="ha-row ha-mini">{bridgeStatus}</div>
+      )}
+      {renderSection(
+        'Layer Explorer — Photoshop-style stack inspector',
+        <>
+          <button
+            className="ha-btn ha-ghost"
+            type="button"
+            onClick={() =>
+              refreshLayerInspector(undefined, undefined, { force: true })
+            }
+            data-ha-tooltip="Re-sample the DOM stack around the locked element"
+          >
+            Refresh Layers
+          </button>
+          <button
+            className="ha-btn"
+            type="button"
+            onClick={() =>
+              setLayerInspectorOpen((value) => {
+                const next = !value;
+                if (next) {
+                  refreshLayerInspector(undefined, undefined, { force: true });
+                } else {
+                  resetHiddenLayers();
+                }
+                return next;
+              })
+            }
+            data-ha-tooltip="Open a floating Photoshop-style layer explorer"
+          >
+            {layerInspectorOpen ? 'Hide Layer Panel' : 'Open Layer Panel'}
+          </button>
+        </>
+      )}
+      {renderSection(
+        'Bridge Helper — manage WSL listener',
+        <>
+          <button
+            className="ha-btn ha-ghost"
+            type="button"
+            onClick={() => refreshBridgeHealth()}
+            disabled={bridgeChecking}
+            data-ha-tooltip="Ping the WSL bridge once to see if it is online"
+          >
+            {bridgeChecking ? 'Handshaking…' : 'Handshake'}
+          </button>
+          <button
+            className="ha-btn ha-ghost"
+            type="button"
+            onClick={stopBridge}
+            disabled={bridgeStopping}
+            data-ha-tooltip="Send a shutdown request to the local bridge listener"
+          >
+            {bridgeStopping ? 'Stopping Bridge…' : 'Stop Bridge'}
+          </button>
+          <button
+            className="ha-btn"
+            type="button"
+            onClick={() => setBridgePanelOpen((value) => !value)}
+            data-ha-tooltip="Open the floating bridge helper window"
+          >
+            {bridgePanelOpen ? 'Hide Bridge Panel' : 'Open Bridge Panel'}
+          </button>
+          <button
+            className="ha-btn ha-ghost"
+            type="button"
+            onClick={openBridgeHealth}
+            data-ha-tooltip="Open the bridge health endpoint in a new tab"
+          >
+            Open Health
+          </button>
+        </>
+      )}
+    </>
+  );
+
+  const renderSettings = () => (
+    <>
+      <div className="ha-row ha-mini">
+        Overlay Transparency (0 = solid, 100 = nearly invisible):{' '}
+        {Math.round((1 - overlayOpacity) * 100)}%
+      </div>
+      <div className="ha-row">
+        <input
+          type="range"
+          min="0"
+          max="100"
+          step="1"
+          value={Math.round((1 - overlayOpacity) * 100)}
+          onChange={(event) => {
+            const sliderValue = Math.min(
+              100,
+              Math.max(0, parseInt(event.target.value, 10) || 0)
+            );
+            const nextOpacity = clampOpacity(1 - sliderValue / 100);
+            setOverlayOpacity(nextOpacity);
+          }}
+          style={{
+            width: '100%',
+            accentColor: '#f97316',
+            background: 'transparent',
+          }}
+        />
+      </div>
+      <div className="ha-row ha-mini">
+        Overlay Hotkey (Ctrl/Cmd + Shift + key)
+      </div>
+      <div className="ha-row">
+        <input
+          className="ha-input"
+          value={dashboardHotkey}
+          onChange={(event) =>
+            setDashboardHotkey(normalizeKey(event.target.value))
+          }
+          placeholder="space"
+          style={{
+            background: inputBackground,
+            borderColor,
+          }}
+        />
+      </div>
+      <div className="ha-row ha-mini">Command Endpoint</div>
+      <div className="ha-row">
+        <input
+          className="ha-input"
+          value={commandEndpoint}
+          onChange={(event) => setCommandEndpoint(event.target.value)}
+          placeholder="http://127.0.0.1:5056/command"
+          style={{
+            background: inputBackground,
+            borderColor,
+          }}
+        />
+      </div>
+      <div className="ha-row ha-mini">Debug Logging</div>
+      <div className="ha-row">
+        <label style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
+          <input
+            type="checkbox"
+            checked={debugMode}
+            onChange={(event) => setDebugMode(event.target.checked)}
+          />
+          <span>{debugMode ? 'Enabled' : 'Disabled'}</span>
+        </label>
+      </div>
+      <div className="ha-row ha-mini">Auto-lock on click</div>
+      <div className="ha-row">
+        <label style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
+          <input
+            type="checkbox"
+            checked={autoLockOnClick}
+            onChange={(event) => setAutoLockOnClick(event.target.checked)}
+          />
+          <span>
+            {autoLockOnClick
+              ? 'Click anywhere to lock'
+              : 'Require Ctrl/Cmd+click'}
+          </span>
+        </label>
+      </div>
+    </>
+  );
+
+  return (
+    <div
+      ref={panelRef}
+      className="ha-panel"
+      data-ha-ui="true"
+      style={{
+        background: panelBackground,
+        border: `1px solid ${borderColor}`,
+        boxShadow: `0 18px 40px ${panelShadow}`,
+        maxHeight: panelMaxHeight,
+        minHeight: 360,
+        height: panelSize.height,
+        overflow: 'hidden',
+        width: panelSize.width,
+      }}
+    >
+      <div
+        className="ha-row ha-drag-handle"
+        title="Drag"
+        onDoubleClick={handlePanelMaxToggle}
+        style={{ position: 'relative' }}
+      >
+        <div style={{ display: 'flex', gap: 6, alignItems: 'center' }}>
+          <span className="ha-dot" />
+          <span className="ha-title">Highlight Assist</span>
+        </div>
+        <div
+          style={{
+            marginLeft: 'auto',
+            display: 'flex',
+            gap: 8,
+            alignItems: 'center',
+          }}
+        >
+          <button
+            type="button"
+            className="ha-help-icon"
+            data-ha-tooltip="Show usage tips for the Highlight Assist controls"
+            onClick={(event) => {
+              event.stopPropagation();
+              const rect = event.currentTarget.getBoundingClientRect();
+              openHelpBubble({
+                anchor: rect,
+                title: 'Highlight Assist Controls',
+                lines: [
+                  {
+                    label: 'Enable',
+                    text: 'toggles the inspector overlay (Ctrl/Cmd+Shift+H).',
+                  },
+                  {
+                    label: 'Lock Element',
+                    text: 'freezes the hovered element so you can copy selectors.',
+                  },
+                  {
+                    label: 'Layer & Bridge panels',
+                    text: 'open floating helpers for stack inspection & bridge setup.',
+                  },
+                  {
+                    label: 'Ctrl/Cmd + click',
+                    text: 'locks the hovered element; click again to release.',
+                  },
+                  {
+                    label: 'Compose Command',
+                    text: 'ships instructions to the listener with current context.',
+                  },
+                ],
+              });
+            }}
+            onMouseDown={(event) => event.stopPropagation()}
+            onDoubleClick={(event) => event.stopPropagation()}
+          >
+            ?
+          </button>
+          <button
+            type="button"
+            className="ha-btn ha-ghost"
+            onClick={() => setHidden(true)}
+            style={{ width: 'auto', padding: '4px 8px' }}
+            data-ha-tooltip="Collapse the panel without disabling the overlay"
+            onMouseDown={(event) => event.stopPropagation()}
+          >
+            Hide
+          </button>
+        </div>
+      </div>
+      <div className="ha-row" style={{ display: 'flex', gap: 8 }}>
+        {['controls', 'settings'].map((tab) => (
+          <button
+            key={tab}
+            type="button"
+            className="ha-btn ha-ghost"
+            onClick={() => setActiveTab(tab)}
+            aria-pressed={activeTab === tab}
+            style={{
+              flex: 1,
+              border: activeTab === tab ? '1px solid #60a5fa' : undefined,
+            }}
+          >
+            {tab === 'controls' ? 'Controls' : 'Settings'}
+          </button>
+        ))}
+      </div>
+      <div
+        style={{
+          maxHeight: panelBodyMaxHeight,
+          overflowY: 'auto',
+          paddingRight: 6,
+          paddingBottom: 12,
+        }}
+        data-ha-ui="true"
+        className="ha-panel-scroll"
+      >
+        <div>{activeTab === 'controls' ? renderControls() : renderSettings()}</div>
+        <div className="ha-row ha-mini" title={currentSelector ?? ''}>
+          {currentSelector ? (
+            <code className="ha-code">{currentSelector}</code>
+          ) : (
+            <span className="ha-muted">Hover to see selector…</span>
+          )}
+        </div>
+      </div>
+      {PANEL_RESIZE_HANDLES.map((handle) => (
+        <span
+          key={handle}
+          data-panel-resize={handle}
+          data-ha-ui="true"
+          className={`ha-resize-handle ha-resize-${handle}`}
+          aria-hidden="true"
+        />
+      ))}
+    </div>
+  );
+};
+
+const LayerExplorerFloatingPanel = () => {
+  const {
+    layerInspectorOpen,
+    setLayerInspectorOpen,
+    layerItems,
+    refreshLayerInspector,
+    lockElementTarget,
+    copySelector,
+    overlayOpacity,
+    hiddenLayerSelectors,
+    toggleLayerVisibility,
+    resetHiddenLayers,
+    openHelpBubble,
+  } = useHighlightAssist();
+  const panelRef = useRef(null);
+  const dragRef = useRef(null);
+  const resizeDragRef = useRef(null);
+  const positionRef = useRef({ x: 320, y: 48 });
+  const LAYER_RESIZE_HANDLES = useMemo(
+    () => [
+      'top-left',
+      'top',
+      'top-right',
+      'right',
+      'bottom-right',
+      'bottom',
+      'bottom-left',
+      'left',
+    ],
+    []
+  );
+  const [panelSize, setPanelSize] = useState({ width: 320, height: 360 });
+  const [layerIsMaximized, setLayerIsMaximized] = useState(false);
+  const layerIsMaximizedRef = useRef(layerIsMaximized);
+  const layerRestoreStateRef = useRef({
+    size: { width: panelSize.width, height: panelSize.height },
+    position: { ...positionRef.current },
+  });
+  const panelSizeRef = useRef(panelSize);
+  const viewportRef = useRef({
+    width: typeof window !== 'undefined' ? window.innerWidth : 1280,
+    height: typeof window !== 'undefined' ? window.innerHeight : 720,
+  });
+  const updateLayerTransform = useCallback((next) => {
+    positionRef.current = next;
+    if (panelRef.current) {
+      panelRef.current.style.transform = `translate(${next.x}px, ${next.y}px)`;
+    }
+  }, []);
+  const surfaces = buildSurfaceColors(overlayOpacity);
+  const panelBackground = `linear-gradient(145deg, rgba(15,23,42,${
+    0.75 + surfaces.base * 0.2
+  }), rgba(2,6,23,${0.92}))`;
+  const borderColor = `rgba(148,163,184,${0.25 + surfaces.base * 0.35})`;
+  const shadow = `0 24px 60px rgba(2,6,23,${0.5 + surfaces.base * 0.3})`;
+
+  useEffect(() => {
+    if (!layerInspectorOpen) {
+      return;
+    }
+    updateLayerTransform(positionRef.current);
+  }, [layerInspectorOpen, updateLayerTransform]);
+
+  useEffect(() => {
+    panelSizeRef.current = panelSize;
+  }, [panelSize]);
+
+  const clampSize = useCallback(
+    (value, min, max) => Math.min(max, Math.max(min, value)),
+    []
+  );
+
+  const startLayerResize = useCallback((type, clientX, clientY) => {
+    resizeDragRef.current = {
+      type,
+      startX: clientX,
+      startY: clientY,
+      width: panelSizeRef.current.width,
+      height: panelSizeRef.current.height,
+      x: positionRef.current.x,
+      y: positionRef.current.y,
+    };
+  }, []);
+
+  const applyLayerResize = useCallback(
+    (clientX, clientY) => {
+      const state = resizeDragRef.current;
+      if (!state) {
+        return;
+      }
+      const dx = clientX - state.startX;
+      const dy = clientY - state.startY;
+
+      const minWidth = 280;
+      const minHeight = 220;
+      const maxWidth = Math.max(minWidth, viewportRef.current.width - 64);
+      const maxHeight = Math.max(minHeight, viewportRef.current.height - 80);
+
+      let nextWidth = state.width;
+      let nextHeight = state.height;
+      let nextX = state.x;
+      let nextY = state.y;
+
+      const includes = (segment) => state.type.includes(segment);
+
+      if (state.type === 'right' || includes('right')) {
+        nextWidth = clampSize(state.width + dx, minWidth, maxWidth);
+      }
+
+      if (state.type === 'left' || includes('left')) {
+        const candidate = clampSize(state.width - dx, minWidth, maxWidth);
+        const delta = state.width - candidate;
+        nextWidth = candidate;
+        nextX = state.x + delta;
+      }
+
+      if (state.type === 'bottom' || includes('bottom')) {
+        nextHeight = clampSize(state.height + dy, minHeight, maxHeight);
+      }
+
+      if (state.type === 'top' || includes('top')) {
+        const candidate = clampSize(state.height - dy, minHeight, maxHeight);
+        const delta = state.height - candidate;
+        nextHeight = candidate;
+        nextY = state.y + delta;
+      }
+
+      setPanelSize((prev) => {
+        if (prev.width === nextWidth && prev.height === nextHeight) {
+          return prev;
+        }
+        return { width: nextWidth, height: nextHeight };
+      });
+      if (nextX !== positionRef.current.x || nextY !== positionRef.current.y) {
+        updateLayerTransform({ x: nextX, y: nextY });
+      }
+    },
+    [clampSize, updateLayerTransform]
+  );
+
+  useEffect(() => {
+    if (!layerIsMaximized) {
+      layerRestoreStateRef.current = {
+        size: { width: panelSize.width, height: panelSize.height },
+        position: { ...positionRef.current },
+      };
+    }
+  }, [layerIsMaximized, panelSize]);
+
+  useEffect(() => {
+    layerIsMaximizedRef.current = layerIsMaximized;
+  }, [layerIsMaximized]);
+
+  useEffect(() => {
+    if (typeof window === 'undefined') {
+      return;
+    }
+    const handleResize = () => {
+      viewportRef.current = {
+        width: window.innerWidth,
+        height: window.innerHeight,
+      };
+      setPanelSize((prev) => {
+        const maxWidth = Math.max(280, window.innerWidth - 160);
+        const maxHeight = Math.max(220, window.innerHeight - 120);
+        return {
+          width: Math.min(prev.width, maxWidth),
+          height: Math.min(prev.height, maxHeight),
+        };
+      });
+    };
+    window.addEventListener('resize', handleResize);
+    return () => window.removeEventListener('resize', handleResize);
+  }, []);
+
+  useEffect(() => {
+    if (!layerIsMaximized) {
+      layerRestoreStateRef.current = {
+        size: { width: panelSize.width, height: panelSize.height },
+        position: { ...positionRef.current },
+      };
+    }
+  }, [layerIsMaximized, panelSize]);
+
+  useEffect(() => {
+    layerIsMaximizedRef.current = layerIsMaximized;
+  }, [layerIsMaximized]);
+
+  useEffect(() => {
+    if (!layerInspectorOpen) {
+      setLayerIsMaximized(false);
+    }
+  }, [layerInspectorOpen]);
+
+  const handleLayerMaxToggle = useCallback(() => {
+    if (typeof window === 'undefined') {
+      return;
+    }
+    if (!layerIsMaximizedRef.current) {
+      layerRestoreStateRef.current = {
+        size: { ...panelSizeRef.current },
+        position: { ...positionRef.current },
+      };
+      const maxWidth = clampSize(window.innerWidth - 80, 320, window.innerWidth - 32);
+      const maxHeight = clampSize(window.innerHeight - 120, 260, window.innerHeight - 48);
+      setPanelSize({ width: maxWidth, height: maxHeight });
+      updateLayerTransform({ x: 32, y: 48 });
+      setLayerIsMaximized(true);
+    } else {
+      if (layerRestoreStateRef.current?.size) {
+        setPanelSize(layerRestoreStateRef.current.size);
+      }
+      if (layerRestoreStateRef.current?.position) {
+        updateLayerTransform(layerRestoreStateRef.current.position);
+      }
+      setLayerIsMaximized(false);
+    }
+  }, [clampSize, updateLayerTransform]);
+
+  useEffect(() => {
+    if (!layerInspectorOpen) {
+      return;
+    }
+    const handleDown = (event) => {
+      if (!panelRef.current) {
+        return;
+      }
+      const resizeTarget = event
+        .target
+        .closest('[data-layer-resize]');
+      if (resizeTarget) {
+        setLayerIsMaximized(false);
+        const handle = resizeTarget.getAttribute('data-layer-resize');
+        if (handle) {
+          startLayerResize(handle, event.clientX, event.clientY);
+        }
+        event.preventDefault();
+        return;
+      }
+      if (!event.target.closest('.ha-layer-floating-handle')) {
+        return;
+      }
+      if (layerIsMaximizedRef.current) {
+        setLayerIsMaximized(false);
+        if (layerRestoreStateRef.current?.size) {
+          setPanelSize(layerRestoreStateRef.current.size);
+        }
+      }
+      dragRef.current = {
+        dx: event.clientX - positionRef.current.x,
+        dy: event.clientY - positionRef.current.y,
+      };
+      event.preventDefault();
+    };
+    const handleMove = (event) => {
+      if (resizeDragRef.current) {
+        applyLayerResize(event.clientX, event.clientY);
+        return;
+      }
+      if (!dragRef.current || !panelRef.current) {
+        return;
+      }
+      const next = {
+        x: event.clientX - dragRef.current.dx,
+        y: event.clientY - dragRef.current.dy,
+      };
+      updateLayerTransform(next);
+    };
+    const handleUp = () => {
+      dragRef.current = null;
+      resizeDragRef.current = null;
+    };
+    window.addEventListener('mousedown', handleDown);
+    window.addEventListener('mousemove', handleMove);
+    window.addEventListener('mouseup', handleUp);
+    return () => {
+      window.removeEventListener('mousedown', handleDown);
+      window.removeEventListener('mousemove', handleMove);
+      window.removeEventListener('mouseup', handleUp);
+    };
+  }, [clampSize, layerInspectorOpen]);
+
+  useEffect(() => {
+    if (!layerInspectorOpen) {
+      return;
+    }
+    refreshLayerInspector(undefined, undefined, { force: true });
+  }, [
+    applyLayerResize,
+    layerInspectorOpen,
+    refreshLayerInspector,
+    startLayerResize,
+    updateLayerTransform,
+  ]);
+
+  const handleClose = useCallback(() => {
+    setLayerInspectorOpen(false);
+    resetHiddenLayers();
+    setLayerIsMaximized(false);
+  }, [resetHiddenLayers, setLayerInspectorOpen]);
+
+  if (!layerInspectorOpen) {
+    return null;
+  }
+
+  return (
+    <div
+      ref={panelRef}
+      className="ha-panel ha-layer-floating"
+      data-ha-ui="true"
+      style={{
+        background: panelBackground,
+        border: `1px solid ${borderColor}`,
+        boxShadow: shadow,
+        width: panelSize.width,
+        height: panelSize.height,
+        padding: 14,
+        display: 'flex',
+        flexDirection: 'column',
+        zIndex: 2147483647,
+      }}
+    >
+      <div
+        className="ha-layer-floating-header ha-layer-floating-handle"
+        style={{ cursor: 'grab', position: 'relative' }}
+        onDoubleClick={handleLayerMaxToggle}
+      >
+        <div>
+          <div className="ha-layer-title">Layer Explorer</div>
+          <div className="ha-layer-subtitle">
+            Drag to reposition. Inspect layers like Photoshop.
+          </div>
+        </div>
+        <div className="ha-layer-floating-actions">
+          <button
+            type="button"
+            className="ha-help-icon"
+            data-ha-tooltip="Show help for the layer explorer window"
+            onClick={(event) => {
+              event.stopPropagation();
+              const rect = event.currentTarget.getBoundingClientRect();
+              openHelpBubble({
+                anchor: rect,
+                title: 'Layer Explorer',
+                lines: [
+                  {
+                    label: 'Eye icon',
+                    text: 'toggles visibility to inspect elements behind overlaps.',
+                  },
+                  {
+                    label: 'Lock',
+                    text: 'jumps to the selected layer in the page.',
+                  },
+                  {
+                    label: 'Copy',
+                    text: 'copies the selector for any row for reuse.',
+                  },
+                  {
+                    label: 'Refresh',
+                    text: 're-samples the stack after DOM changes.',
+                  },
+                ],
+              });
+            }}
+            onMouseDown={(event) => event.stopPropagation()}
+            onDoubleClick={(event) => event.stopPropagation()}
+          >
+            ?
+          </button>
+          <button
+            type="button"
+            className="ha-btn ha-ghost"
+            style={{ width: 'auto' }}
+            onClick={() =>
+              refreshLayerInspector(undefined, undefined, { force: true })
+            }
+            data-ha-tooltip="Rescan the DOM stack near the locked element"
+            onMouseDown={(event) => event.stopPropagation()}
+          >
+            Refresh
+          </button>
+          <button
+            type="button"
+            className="ha-btn ha-ghost"
+            style={{ width: 'auto' }}
+            onClick={handleClose}
+            data-ha-tooltip="Close the floating layer explorer"
+            onMouseDown={(event) => event.stopPropagation()}
+          >
+            Close
+          </button>
+        </div>
+        {/* Help bubble is rendered via HelpBubble portal */}
+      </div>
+      <div className="ha-layer-hint">
+        {layerItems.length
+          ? 'Top rows render closest to the viewer.'
+          : 'Move your cursor over stacked elements to populate this list.'}
+      </div>
+      <div
+        className="ha-layer-list"
+        data-ha-ui="true"
+        style={{
+          maxHeight: Math.max(140, panelSize.height - 190),
+        }}
+      >
+        {layerItems.map((item, index) => {
+          const layerNumber = layerItems.length - index;
+          const isHidden = hiddenLayerSelectors.includes(item.selector);
+          return (
+            <div
+              key={`${item.selector}-${index}`}
+              className="ha-layer-card"
+              data-ha-ui="true"
+            >
+              <div className="ha-layer-meta">
+                <button
+                  type="button"
+                  className={`ha-layer-icon-btn ${
+                    isHidden ? 'is-muted' : ''
+                  }`}
+                  onClick={() =>
+                    toggleLayerVisibility(item.element, item.selector)
+                  }
+                  data-ha-tooltip={
+                    isHidden
+                      ? 'Show this layer again'
+                      : 'Hide this layer to reveal what is beneath'
+                  }
+                >
+                  <span className="ha-layer-eye">
+                    <span className="ha-layer-eye-pupil" />
+                  </span>
+                </button>
+                <div className="ha-layer-thumb" aria-hidden="true">
+                  <div className="ha-layer-thumb-border">
+                    <div
+                      className={`ha-layer-thumb-shape${
+                        item.preview.hasImage ? ' has-image' : ''
+                      }`}
+                      style={{
+                        background: item.preview.background,
+                        borderRadius: item.preview.borderRadius,
+                      }}
+                    />
+                  </div>
+                </div>
+                <div className="ha-layer-meta-body">
+                  <div className="ha-layer-meta-top">
+                    <div
+                      className="ha-layer-index"
+                      aria-label={`Layer ${layerNumber}`}
+                    >
+                      #{layerNumber}
+                    </div>
+                    <div className="ha-layer-dimensions">
+                      {Math.round(Math.max(1, item.rect.width))}×
+                      {Math.round(Math.max(1, item.rect.height))}
+                    </div>
+                  </div>
+                  <div className="ha-layer-label">{item.label}</div>
+                  <div className="ha-layer-selector">{item.selector}</div>
+                </div>
+              </div>
+              <div className="ha-layer-card-actions">
+                <button
+                  type="button"
+                  className="ha-btn"
+                  onClick={() => lockElementTarget(item.element)}
+                  data-ha-tooltip="Lock onto this layer's element"
+                >
+                  Lock
+                </button>
+                <button
+                  type="button"
+                  className="ha-btn ha-ghost"
+                  onClick={() => copySelector(item.selector)}
+                  data-ha-tooltip="Copy the selector for this layer"
+                >
+                  Copy
+                </button>
+              </div>
+            </div>
+          );
+        })}
+      </div>
+      <div className="ha-layer-footer">
+        <button
+          type="button"
+          className="ha-btn ha-ghost"
+          onClick={resetHiddenLayers}
+          style={{ width: '100%' }}
+          disabled={!hiddenLayerSelectors.length}
+          data-ha-tooltip="Restore visibility for every hidden layer"
+        >
+          {hiddenLayerSelectors.length
+            ? 'Restore Hidden Layers'
+            : 'All layers visible'}
+        </button>
+      </div>
+      {LAYER_RESIZE_HANDLES.map((handle) => (
+        <span
+          key={handle}
+          data-layer-resize={handle}
+          data-ha-ui="true"
+          className={`ha-resize-handle ha-resize-${handle}`}
+          aria-hidden="true"
+        />
+      ))}
+    </div>
+  );
+};
+
+const BridgeHelperFloatingPanel = () => {
+  const {
+    bridgePanelOpen,
+    setBridgePanelOpen,
+    bridgeChecking,
+    bridgeHealthy,
+    bridgeLastCheck,
+    bridgeError,
+    bridgeMonitorEnabled,
+    setBridgeMonitorEnabled,
+    refreshBridgeHealth,
+    bridgeWsUrl,
+    setBridgeWsUrl,
+    bridgeToken,
+    setBridgeToken,
+    copyBridgeCommand,
+    copyBridgeUrl,
+    copyBridgeToken,
+    openBridgeHealth,
+    stopBridge,
+    bridgeStopping,
+    bridgeStatus,
+    openHelpBubble,
+  } = useHighlightAssist();
+  const panelRef = useRef(null);
+  const dragRef = useRef(null);
+  const resizeDragRef = useRef(null);
+  const getInitialBridgeSize = () => {
+    if (typeof window === 'undefined') {
+      return { width: 380, height: 480 };
+    }
+    return {
+      width: Math.min(Math.max(380, window.innerWidth * 0.3), window.innerWidth - 48),
+      height: Math.min(Math.max(420, window.innerHeight * 0.45), window.innerHeight - 64),
+    };
+  };
+  const [panelSize, setPanelSize] = useState(getInitialBridgeSize);
+  const panelSizeRef = useRef(panelSize);
+  const positionRef = useRef({ x: 420, y: 140 });
+  const viewportRef = useRef({
+    width: typeof window !== 'undefined' ? window.innerWidth : 1440,
+    height: typeof window !== 'undefined' ? window.innerHeight : 900,
+  });
+  const BRIDGE_RESIZE_HANDLES = useMemo(
+    () => [
+      'top-left',
+      'top',
+      'top-right',
+      'right',
+      'bottom-right',
+      'bottom',
+      'bottom-left',
+      'left',
+    ],
+    []
+  );
+  const clampBridgeSize = useCallback(
+    (value, min, max) => Math.min(max, Math.max(min, value)),
+    []
+  );
+  const updatePanelTransform = useCallback((next) => {
+    positionRef.current = next;
+    if (panelRef.current) {
+      panelRef.current.style.transform = `translate(${next.x}px, ${next.y}px)`;
+    }
+  }, []);
+
+  useEffect(() => {
+    panelSizeRef.current = panelSize;
+  }, [panelSize]);
+
+  useEffect(() => {
+    if (!bridgePanelOpen) {
+      return;
+    }
+    updatePanelTransform(positionRef.current);
+  }, [bridgePanelOpen, updatePanelTransform]);
+
+  useEffect(() => {
+    if (typeof window === 'undefined') {
+      return;
+    }
+    const handleResize = () => {
+      viewportRef.current = {
+        width: window.innerWidth,
+        height: window.innerHeight,
+      };
+      const minWidth = 320;
+      const minHeight = 320;
+      const maxWidth = Math.max(minWidth, window.innerWidth - 48);
+      const maxHeight = Math.max(minHeight, window.innerHeight - 64);
+      setPanelSize((prev) => ({
+        width: clampBridgeSize(prev.width, minWidth, maxWidth),
+        height: clampBridgeSize(prev.height, minHeight, maxHeight),
+      }));
+    };
+    window.addEventListener('resize', handleResize);
+    return () => window.removeEventListener('resize', handleResize);
+  }, [clampBridgeSize]);
+
+  const startBridgeResize = useCallback((type, clientX, clientY) => {
+    resizeDragRef.current = {
+      type,
+      startX: clientX,
+      startY: clientY,
+      width: panelSizeRef.current.width,
+      height: panelSizeRef.current.height,
+      x: positionRef.current.x,
+      y: positionRef.current.y,
+    };
+  }, []);
+
+  const applyBridgeResize = useCallback(
+    (clientX, clientY) => {
+      const state = resizeDragRef.current;
+      if (!state) {
+        return;
+      }
+      const dx = clientX - state.startX;
+      const dy = clientY - state.startY;
+      const minWidth = 320;
+      const minHeight = 320;
+      const maxWidth = Math.max(minWidth, viewportRef.current.width - 48);
+      const maxHeight = Math.max(minHeight, viewportRef.current.height - 64);
+      let nextWidth = state.width;
+      let nextHeight = state.height;
+      let nextX = state.x;
+      let nextY = state.y;
+      const includes = (segment) => state.type.includes(segment);
+      if (state.type === 'right' || includes('right')) {
+        nextWidth = clampBridgeSize(state.width + dx, minWidth, maxWidth);
+      }
+      if (state.type === 'left' || includes('left')) {
+        const candidate = clampBridgeSize(state.width - dx, minWidth, maxWidth);
+        const delta = state.width - candidate;
+        nextWidth = candidate;
+        nextX = state.x + delta;
+      }
+      if (state.type === 'bottom' || includes('bottom')) {
+        nextHeight = clampBridgeSize(state.height + dy, minHeight, maxHeight);
+      }
+      if (state.type === 'top' || includes('top')) {
+        const candidate = clampBridgeSize(state.height - dy, minHeight, maxHeight);
+        const delta = state.height - candidate;
+        nextHeight = candidate;
+        nextY = state.y + delta;
+      }
+      setPanelSize((prev) => {
+        if (prev.width === nextWidth && prev.height === nextHeight) {
+          return prev;
+        }
+        return { width: nextWidth, height: nextHeight };
+      });
+      if (nextX !== positionRef.current.x || nextY !== positionRef.current.y) {
+        updatePanelTransform({ x: nextX, y: nextY });
+      }
+    },
+    [clampBridgeSize, updatePanelTransform]
+  );
+
+  useEffect(() => {
+    if (!bridgePanelOpen) {
       return;
     }
-
     const handleDown = (event) => {
       if (!panelRef.current) {
         return;
       }
-      if (!event.target.closest('.ha-drag-handle')) {
+      const root = panelRef.current;
+      if (!root.contains(event.target)) {
+        return;
+      }
+      const resizeTarget = event.target.closest('[data-bridge-resize]');
+      if (resizeTarget && root.contains(resizeTarget)) {
+        const handle = resizeTarget.getAttribute('data-bridge-resize');
+        if (handle) {
+          startBridgeResize(handle, event.clientX, event.clientY);
+        }
+        event.preventDefault();
+        return;
+      }
+      const dragHandle = event.target.closest('.ha-bridge-floating-handle');
+      if (!dragHandle || !root.contains(dragHandle)) {
         return;
       }
       dragRef.current = {
@@ -620,271 +2781,357 @@ const Panel = () => {
       };
       event.preventDefault();
     };
-
     const handleMove = (event) => {
+      if (resizeDragRef.current) {
+        applyBridgeResize(event.clientX, event.clientY);
+        return;
+      }
       if (!dragRef.current || !panelRef.current) {
         return;
       }
-
-      const next = {
+      positionRef.current = {
         x: event.clientX - dragRef.current.dx,
         y: event.clientY - dragRef.current.dy,
       };
-
-      positionRef.current = next;
-      panelRef.current.style.transform = `translate(${next.x}px, ${next.y}px)`;
+      updatePanelTransform(positionRef.current);
     };
-
     const handleUp = () => {
       dragRef.current = null;
+      resizeDragRef.current = null;
     };
-
     window.addEventListener('mousedown', handleDown);
     window.addEventListener('mousemove', handleMove);
     window.addEventListener('mouseup', handleUp);
-
     return () => {
       window.removeEventListener('mousedown', handleDown);
       window.removeEventListener('mousemove', handleMove);
       window.removeEventListener('mouseup', handleUp);
     };
-  }, []);
-
-  const copySelector = async () => {
-    if (!currentSelector || typeof navigator === 'undefined') {
-      return;
-    }
-
-    try {
-      await navigator.clipboard.writeText(currentSelector);
-    } catch (error) {
-      debugLog('clipboard copy failed', error);
-    }
-  };
+  }, [applyBridgeResize, bridgePanelOpen, startBridgeResize, updatePanelTransform]);
 
-  if (hidden) {
-    return (
-      <div
-        ref={panelRef}
-        className="ha-panel"
-        style={{
-          width: 'auto',
-          padding: '6px 10px',
-          display: 'inline-flex',
-          alignItems: 'center',
-          gap: '8px',
-          background: panelBackground,
-          border: `1px solid ${borderColor}`,
-        }}
-      >
-        <span style={{ fontSize: '12px' }}>Highlight Assist hidden</span>
-        <button
-          type="button"
-          className="ha-btn"
-          style={{ width: 'auto' }}
-          onClick={() => setHidden(false)}
-        >
-          Show
-        </button>
-      </div>
-    );
+  if (!bridgePanelOpen) {
+    return null;
   }
 
   return (
     <div
       ref={panelRef}
-      className="ha-panel"
+      className="ha-panel ha-bridge-floating"
+      data-ha-ui="true"
       style={{
-        background: panelBackground,
-        border: `1px solid ${borderColor}`,
-        boxShadow: `0 18px 40px ${panelShadow}`,
+        width: panelSize.width,
+        height: panelSize.height,
+        minWidth: 320,
+        minHeight: 320,
+        padding: 14,
+        borderRadius: 16,
+        border: '1px solid rgba(148,163,184,0.35)',
+        background: 'rgba(15,23,42,0.92)',
+        boxShadow: '0 24px 48px rgba(2,6,23,0.65)',
+        zIndex: 2147483647,
+        overflow: 'hidden',
+        display: 'flex',
+        flexDirection: 'column',
       }}
     >
-      <div className="ha-row ha-drag-handle" title="Drag">
-        <span className="ha-dot" />
-        <span className="ha-title">Highlight Assist</span>
-        <button
-          type="button"
-          className="ha-btn ha-ghost"
-          onClick={() => setHidden(true)}
-          style={{ width: 'auto', padding: '4px 8px', marginLeft: 'auto' }}
-        >
-          Hide
-        </button>
-        <button
-          type="button"
-          className="ha-btn ha-ghost"
-          onClick={() => setShowSettings((prev) => !prev)}
-          style={{ width: 'auto', padding: '4px 8px', marginLeft: 6 }}
-        >
-          {showSettings ? 'Close Settings' : 'Settings'}
-        </button>
-      </div>
-      <div className="ha-row">
-        <button
-          type="button"
-          className="ha-btn"
-          onClick={() => setEnabled(!enabled)}
-          aria-pressed={enabled}
-        >
-          {enabled
-            ? 'Disable (Ctrl/Cmd+Shift+H)'
-            : 'Enable (Ctrl/Cmd+Shift+H)'}
-        </button>
-      </div>
-      <div className="ha-row">
-        <button
-          type="button"
-          className="ha-btn"
-          onClick={() => lock(!locked)}
-          aria-pressed={locked}
-          disabled={!enabled}
-        >
-          {locked ? 'Unlock Element' : 'Lock Element'}
-        </button>
-      </div>
-      <div className="ha-row">
-        <button
-          type="button"
-          className="ha-btn"
-          onClick={copySelector}
-          disabled={!currentSelector}
-        >
-          Copy Selector
-        </button>
-      </div>
-      <div className="ha-row">
-        <button
-          type="button"
-          className="ha-btn ha-ghost"
-          onClick={() => setShowGrid(!showGrid)}
-          aria-pressed={showGrid}
-        >
-          {showGrid
-            ? 'Hide Grid (Ctrl/Cmd+Shift+G)'
-            : 'Show Grid (Ctrl/Cmd+Shift+G)'}
-        </button>
+      <div
+        className="ha-bridge-floating-header ha-bridge-floating-handle ha-drag-handle"
+        style={{ cursor: 'grab', position: 'relative' }}
+      >
+        <div>
+          <div className="ha-layer-title">Bridge Helper</div>
+          <div className="ha-layer-subtitle">
+            Drag to reposition. Manage the WSL command hub from here.
+          </div>
+        </div>
+        <div style={{ display: 'flex', gap: 8 }}>
+          <button
+            type="button"
+            className="ha-help-icon"
+            data-ha-tooltip="Show usage tips for the bridge helper"
+            onClick={(event) => {
+              event.stopPropagation();
+              const rect = event.currentTarget.getBoundingClientRect();
+              openHelpBubble({
+                anchor: rect,
+                title: 'Bridge Helper',
+                lines: [
+                  {
+                    label: 'Handshake',
+                    text: 'performs a single `/health` request.',
+                  },
+                  {
+                    label: 'Auto monitor',
+                    text: 'keeps checking every 5 seconds and updates the dot.',
+                  },
+                  {
+                    label: 'Copy buttons',
+                    text: 'reuse the launch script, WebSocket URL, or token.',
+                  },
+                  {
+                    label: 'Stop Bridge',
+                    text: 'shuts down the listener before restarting.',
+                  },
+                ],
+              });
+            }}
+            onMouseDown={(event) => event.stopPropagation()}
+            onDoubleClick={(event) => event.stopPropagation()}
+          >
+            ?
+          </button>
+          <button
+            type="button"
+            className="ha-btn ha-ghost"
+            style={{ width: 'auto' }}
+            onClick={() => setBridgePanelOpen(false)}
+            data-ha-tooltip="Close the bridge helper window"
+            onMouseDown={(event) => event.stopPropagation()}
+          >
+            Close
+          </button>
+        </div>
       </div>
-      {showSettings && (
-        <>
-          <div className="ha-row ha-mini">
-            Overlay Transparency ({Math.round(
-              Math.min(Math.max(overlayOpacity, 0.05), 1) * 100
-            )}
-            %)
+      <div
+        className="ha-panel-scroll"
+        style={{ flex: 1, overflowY: 'auto', paddingRight: 2 }}
+        data-ha-ui="true"
+      >
+        <div className="ha-bridge-card" data-ha-ui="true">
+        <div className="ha-bridge-header">
+          <div className="ha-bridge-status">
+            <span
+              className={`ha-status-dot ${
+                bridgeHealthy === null
+                  ? 'is-idle'
+                  : bridgeHealthy
+                    ? 'is-ok'
+                    : 'is-offline'
+              }`}
+            />
+            <div>
+              <div className="ha-bridge-title-text">
+                {bridgeHealthy === null
+                  ? 'Checking bridge…'
+                  : bridgeHealthy
+                    ? 'Bridge online'
+                    : 'Bridge offline'}
+              </div>
+              <div className="ha-bridge-subtext">
+                {bridgeChecking
+                  ? 'Handshaking…'
+                  : bridgeLastCheck
+                    ? `Last check ${new Date(
+                        bridgeLastCheck
+                      ).toLocaleTimeString()}`
+                    : 'No checks yet'}
+              </div>
+            </div>
+          </div>
+          <button
+            type="button"
+            className="ha-btn ha-ghost"
+            onClick={() => refreshBridgeHealth()}
+            disabled={bridgeChecking}
+            data-ha-tooltip="Ping the bridge once to check its status"
+          >
+            {bridgeChecking ? 'Handshaking…' : 'Handshake'}
+          </button>
+        </div>
+        <div className="ha-bridge-monitor-row">
+          <div>
+            <div className="ha-bridge-label">Auto health monitor</div>
+            <div className="ha-bridge-subtext">
+              {bridgeMonitorEnabled
+                ? 'Highlight Assist pings the bridge every 5s.'
+                : 'Disabled — use Handshake to check on demand.'}
+            </div>
           </div>
-          <div className="ha-row">
+          <label
+            className="ha-switch"
+            data-ha-ui="true"
+            data-ha-tooltip="Toggle automatic health checks every 5 seconds"
+          >
             <input
-              type="range"
-              min="0.05"
-              max="1"
-              step="0.01"
-              value={overlayOpacity}
+              type="checkbox"
+              checked={bridgeMonitorEnabled}
               onChange={(event) =>
-                setOverlayOpacity(parseFloat(event.target.value))
+                setBridgeMonitorEnabled(event.target.checked)
               }
-              style={{
-                width: '100%',
-                accentColor: '#f97316',
-                background: 'transparent',
-              }}
             />
+            <span className="ha-switch-slider" />
+          </label>
+        </div>
+        {bridgeError && (
+          <div className="ha-bridge-error">{bridgeError}</div>
+        )}
+        {bridgeHealthy === false && !bridgeChecking && (
+          <div className="ha-bridge-offline">
+            <div>
+              <div className="ha-bridge-offline-title">Bridge not reachable</div>
+              <div className="ha-bridge-offline-text">
+                Start the WSL listener or adjust your settings, then run the
+                launch command.
+              </div>
+            </div>
+            <button
+              type="button"
+              className="ha-btn"
+              onClick={copyBridgeCommand}
+              data-ha-tooltip="Copy the auto-config launch command"
+            >
+              Copy Launch Command
+            </button>
           </div>
-          <div className="ha-row ha-mini">
-            Overlay Hotkey (Ctrl/Cmd + Shift + key)
+        )}
+        <div className="ha-bridge-field">
+          <label className="ha-bridge-label">WebSocket URL</label>
+          <div className="ha-bridge-input">
+            <input
+              className="ha-input"
+              value={bridgeWsUrl}
+              onChange={(event) => setBridgeWsUrl(event.target.value)}
+              placeholder="ws://127.0.0.1:5055/ws"
+            />
+            <button
+              type="button"
+              className="ha-btn ha-ghost ha-btn-inline"
+              onClick={copyBridgeUrl}
+              data-ha-tooltip="Copy the WebSocket URL"
+            >
+              Copy
+            </button>
           </div>
-          <div className="ha-row">
+        </div>
+        <div className="ha-bridge-field">
+          <label className="ha-bridge-label">Token</label>
+          <div className="ha-bridge-input">
             <input
               className="ha-input"
-              value={dashboardHotkey}
-              onChange={(event) =>
-                setDashboardHotkey(normalizeKey(event.target.value))
-              }
-              placeholder="space"
-              style={{
-                background: inputBackground,
-                borderColor,
-              }}
+              value={bridgeToken}
+              onChange={(event) => setBridgeToken(event.target.value)}
+              placeholder="dev-token-change-me"
             />
+            <button
+              type="button"
+              className="ha-btn ha-ghost ha-btn-inline"
+              onClick={copyBridgeToken}
+              data-ha-tooltip="Copy the auth token"
+            >
+              Copy
+            </button>
           </div>
-          <div className="ha-row ha-mini">Debug Logging</div>
-          <div className="ha-row">
-            <label style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
-              <input
-                type="checkbox"
-                checked={debugMode}
-                onChange={(event) => setDebugMode(event.target.checked)}
-              />
-              <span>{debugMode ? 'Enabled' : 'Disabled'}</span>
-            </label>
+        </div>
+        <div className="ha-bridge-field">
+          <label className="ha-bridge-label">Launch Command (WSL)</label>
+          <div className="ha-bridge-command">
+            <div className="ha-bridge-command-text">
+              {BRIDGE_START_COMMAND}
+            </div>
+            <button
+              type="button"
+              className="ha-btn ha-ghost ha-btn-inline"
+              onClick={copyBridgeCommand}
+              data-ha-tooltip="Copy the recommended launch command"
+            >
+              Copy
+            </button>
           </div>
-        </>
-      )}
-      <div className="ha-row">
-        <input
-          className="ha-input"
-          value={commandEndpoint}
-          onChange={(event) => setCommandEndpoint(event.target.value)}
-          placeholder="http://127.0.0.1:5056/command"
-          style={{
-            background: inputBackground,
-            borderColor,
-          }}
-        />
-      </div>
-      <div className="ha-row">
-        <button
-          type="button"
-          className="ha-btn"
-          onClick={() =>
-            openComposer({
-              selector: currentSelector ?? '',
-              snippet: '',
-            })
-          }
-          disabled={!currentSelector}
-        >
-          Compose Command
-        </button>
-      </div>
-      <div className="ha-row" style={{ display: 'flex', gap: '8px' }}>
-        <button
-          type="button"
-          className="ha-btn ha-ghost"
-          onClick={handleUndoInspect}
-          disabled={!hasUndo}
-        >
-          Undo Inspect
-        </button>
-        <button
-          type="button"
-          className="ha-btn ha-ghost"
-          onClick={handleSnapshot}
-          disabled={!currentRect || savingSnapshot}
-        >
-          {savingSnapshot ? 'Saving…' : 'Save Snapshot'}
-        </button>
-      </div>
-      <div className="ha-row">
-        <button
-          type="button"
-          className="ha-btn ha-ghost"
-          onClick={() => setDashboardOpen(true)}
-        >
-          {`Open Dev Overlay (Ctrl/Cmd+Shift+${dashboardHotkey})`}
-        </button>
-      </div>
-      <div className="ha-row ha-mini" title={currentSelector ?? ''}>
-        {currentSelector ? (
-          <code className="ha-code">{currentSelector}</code>
-        ) : (
-          <span className="ha-muted">Hover to see selector…</span>
-        )}
+        </div>
+        <div className="ha-bridge-actions">
+          <button
+            type="button"
+            className="ha-btn"
+            onClick={stopBridge}
+            disabled={bridgeStopping}
+            data-ha-tooltip="Request a graceful shutdown from the bridge"
+          >
+            {bridgeStopping ? 'Stopping…' : 'Stop Bridge'}
+          </button>
+          <button
+            type="button"
+            className="ha-btn ha-ghost"
+            onClick={openBridgeHealth}
+            data-ha-tooltip="Open the bridge health endpoint in a new tab"
+          >
+            Open Health
+          </button>
+        </div>
+          {bridgeStatus && (
+            <div className="ha-bridge-status-note">{bridgeStatus}</div>
+          )}
+        </div>
       </div>
+      {BRIDGE_RESIZE_HANDLES.map((handle) => (
+        <span
+          key={handle}
+          className={`ha-resize-handle ha-resize-${handle}`}
+          data-ha-ui="true"
+          data-bridge-resize={handle}
+          aria-hidden="true"
+        />
+      ))}
+    </div>
+  );
+};
+
+const TooltipOverlay = () => {
+  const { tooltipState } = useHighlightAssist();
+  if (!tooltipState?.visible || !tooltipState.message) {
+    return null;
+  }
+  return (
+    <div
+      className="ha-tooltip"
+      data-ha-ui="true"
+      style={{
+        left: tooltipState.x,
+        top: tooltipState.y,
+      }}
+    >
+      {tooltipState.message}
     </div>
   );
 };
 
+const HelpBubble = () => {
+  const { helpBubble, closeHelpBubble } = useHighlightAssist();
+  if (!helpBubble) {
+    return null;
+  }
+  const position = computePopoverPosition(helpBubble.anchor);
+  if (!position) {
+    return null;
+  }
+  return createPortal(
+    <div
+      className="ha-help-popover"
+      data-ha-ui="true"
+      style={{
+        top: position.top,
+        left: position.left,
+      }}
+    >
+      <div className="ha-help-title">{helpBubble.title}</div>
+      <div className="ha-help-lines">
+        {helpBubble.lines.map((line) => (
+          <div key={line.label} className="ha-help-line">
+            <strong>{line.label}</strong> {line.text}
+          </div>
+        ))}
+      </div>
+      <button
+        type="button"
+        className="ha-btn ha-ghost"
+        onClick={closeHelpBubble}
+      >
+        Close help
+      </button>
+    </div>,
+    document.body
+  );
+};
+
 const CommandComposer = ({ draft, onClose, endpoint, overlayOpacity }) => {
   const [command, setCommand] = useState('');
   const [status, setStatus] = useState(null);
@@ -995,6 +3242,7 @@ const CommandComposer = ({ draft, onClose, endpoint, overlayOpacity }) => {
     <form
       onSubmit={handleSubmit}
       ref={composerRef}
+      data-ha-ui="true"
       style={{
         position: 'fixed',
         left: position?.x ?? draft.x,
@@ -1191,7 +3439,6 @@ export function HighlightAssistProvider({ children }) {
     contextValue.setEnabled(false);
     contextValue.setDashboardOpen(false);
     contextValue.setShowGrid(false);
-    contextValue.setShowSettings?.(false);
   }, [contextValue]);
 
   return (
@@ -1202,39 +3449,43 @@ export function HighlightAssistProvider({ children }) {
         onReset={resetHighlight}
       >
         <>
-        <Overlay
-          rect={contextValue.currentRect}
-          enabled={contextValue.enabled}
-          overlayOpacity={contextValue.overlayOpacity}
-        />
-        <GridOverlay enabled={showGrid} />
-        <Panel />
-        <GameOverlay
-          dashboardOpen={dashboardOpen}
-          setDashboardOpen={contextValue.setDashboardOpen}
-          currentSelector={contextValue.currentSelector}
-          currentSnippet={contextValue.currentSnippet}
-          commandHistory={commandHistory}
-          perfStats={perfStats}
-          toggle={contextValue.toggle}
-          setShowGrid={contextValue.setShowGrid}
-          showGrid={contextValue.showGrid}
-          openComposer={contextValue.openComposer}
-          overlayOpacity={contextValue.overlayOpacity}
-          enabled={contextValue.enabled}
-          dashboardHotkey={dashboardHotkey}
-          hasUndo={hasUndo}
-          handleUndoInspect={handleUndoInspect}
-          handleSnapshot={handleSnapshot}
-          savingSnapshot={savingSnapshot}
-          currentRect={contextValue.currentRect}
-        />
-        <CommandComposer
-          draft={composerDraft}
-          onClose={closeComposer}
-          endpoint={commandEndpoint}
-          overlayOpacity={contextValue.overlayOpacity}
-        />
+          <Overlay
+            rect={contextValue.currentRect}
+            enabled={contextValue.enabled}
+            overlayOpacity={contextValue.overlayOpacity}
+          />
+          <GridOverlay enabled={showGrid} />
+          <Panel />
+        <LayerExplorerFloatingPanel />
+        <BridgeHelperFloatingPanel />
+        <TooltipOverlay />
+        <HelpBubble />
+          <GameOverlay
+            dashboardOpen={dashboardOpen}
+            setDashboardOpen={contextValue.setDashboardOpen}
+            currentSelector={contextValue.currentSelector}
+            currentSnippet={contextValue.currentSnippet}
+            commandHistory={commandHistory}
+            perfStats={perfStats}
+            toggle={contextValue.toggle}
+            setShowGrid={contextValue.setShowGrid}
+            showGrid={contextValue.showGrid}
+            openComposer={contextValue.openComposer}
+            overlayOpacity={contextValue.overlayOpacity}
+            enabled={contextValue.enabled}
+            dashboardHotkey={dashboardHotkey}
+            hasUndo={hasUndo}
+            handleUndoInspect={handleUndoInspect}
+            handleSnapshot={handleSnapshot}
+            savingSnapshot={savingSnapshot}
+            currentRect={contextValue.currentRect}
+          />
+          <CommandComposer
+            draft={composerDraft}
+            onClose={closeComposer}
+            endpoint={commandEndpoint}
+            overlayOpacity={contextValue.overlayOpacity}
+          />
         </>
       </HighlightAssistErrorBoundary>
     </HighlightContext.Provider>
@@ -1289,8 +3540,10 @@ export function HighlightAssistProviderV2({ children }) {
             enabled={contextValue.enabled}
             overlayOpacity={contextValue.overlayOpacity}
           />
-          <GridOverlay enabled={showGrid} />
-          <DevConsole />
+        <GridOverlay enabled={showGrid} />
+        <DevConsole />
+          <TooltipOverlay />
+          <HelpBubble />
           <GameOverlay
             dashboardOpen={dashboardOpen}
             setDashboardOpen={contextValue.setDashboardOpen}
diff --git a/src/highlight/MiniPreview.jsx b/src/highlight/MiniPreview.jsx
index a4e9643..aa78569 100644
--- a/src/highlight/MiniPreview.jsx
+++ b/src/highlight/MiniPreview.jsx
@@ -20,6 +20,7 @@ export default function MiniPreview() {
         flexDirection: 'column',
         gap: 8,
       }}
+      data-ha-ui="true"
     >
       <div style={{ display: 'flex', justifyContent: 'space-between' }}>
         <span style={{ opacity: 0.7, fontSize: 12 }}>
diff --git a/src/highlight/injectStyles.js b/src/highlight/injectStyles.js
index bfb32ea..7b2d5ba 100644
--- a/src/highlight/injectStyles.js
+++ b/src/highlight/injectStyles.js
@@ -25,6 +25,73 @@ const STYLES = `
   width: 260px;
   font: 13px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
     Helvetica, Arial;
+  scrollbar-width: thin;
+  scrollbar-color: rgba(148, 163, 184, 0.35) transparent;
+}
+
+.ha-panel::-webkit-scrollbar {
+  width: 6px;
+}
+
+.ha-panel::-webkit-scrollbar-track {
+  background: transparent;
+}
+
+.ha-panel::-webkit-scrollbar-thumb {
+  background: rgba(148, 163, 184, 0.2);
+  border-radius: 12px;
+}
+
+.ha-panel:hover::-webkit-scrollbar-thumb {
+  background: rgba(148, 163, 184, 0.45);
+}
+
+.ha-panel-scroll {
+  scrollbar-width: thin;
+  scrollbar-color: rgba(148, 163, 184, 0.35) transparent;
+}
+
+.ha-panel-scroll::-webkit-scrollbar {
+  width: 6px;
+}
+
+.ha-panel-scroll::-webkit-scrollbar-thumb {
+  background: rgba(148, 163, 184, 0.2);
+  border-radius: 12px;
+}
+
+.ha-panel-scroll:hover::-webkit-scrollbar-thumb {
+  background: rgba(148, 163, 184, 0.45);
+}
+
+.ha-panel-section {
+  margin-top: 10px;
+  display: flex;
+  flex-direction: column;
+  gap: 6px;
+}
+
+.ha-panel-section-title {
+  font-size: 11px;
+  letter-spacing: 0.1em;
+  text-transform: uppercase;
+  color: rgba(226, 232, 240, 0.8);
+  margin-left: 2px;
+}
+
+.ha-section-grid {
+  display: grid;
+  grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
+  gap: 8px;
+}
+
+.ha-section-grid button {
+  width: 100%;
+}
+
+.ha-btn.ha-section-grid-wide {
+  grid-column: span 2;
+  width: 100%;
 }
 
 .ha-row {
@@ -67,6 +134,12 @@ const STYLES = `
   width: 100%;
 }
 
+.ha-btn-inline {
+  width: auto;
+  flex: 0 0 auto;
+  white-space: nowrap;
+}
+
 .ha-btn[aria-pressed='true'] {
   background: #16a34a;
   color: #ffffff;
@@ -94,6 +167,131 @@ const STYLES = `
   opacity: 0.7;
 }
 
+.ha-help-icon {
+  width: 26px;
+  height: 26px;
+  border-radius: 999px;
+  border: 1px solid rgba(148, 163, 184, 0.4);
+  background: rgba(15, 23, 42, 0.85);
+  color: #e2e8f0;
+  font-weight: 700;
+  font-size: 13px;
+  line-height: 1;
+  display: inline-flex;
+  align-items: center;
+  justify-content: center;
+  cursor: pointer;
+  transition: background 0.15s ease, border-color 0.15s ease;
+}
+
+.ha-help-icon:hover {
+  background: rgba(59, 130, 246, 0.25);
+  border-color: rgba(59, 130, 246, 0.6);
+}
+
+.ha-help-popover {
+  position: fixed;
+  width: min(260px, 80vw);
+  background: rgba(2, 6, 23, 0.95);
+  border: 1px solid rgba(59, 130, 246, 0.35);
+  border-radius: 12px;
+  padding: 12px;
+  box-shadow: 0 20px 45px rgba(2, 6, 23, 0.65);
+  color: #e2e8f0;
+  font-size: 12px;
+  line-height: 1.5;
+  z-index: 2147483647;
+  transform: none;
+}
+
+.ha-help-lines {
+  display: flex;
+  flex-direction: column;
+  gap: 6px;
+  margin-bottom: 8px;
+}
+
+.ha-help-line {
+  font-size: 12px;
+  color: rgba(226, 232, 240, 0.85);
+}
+
+.ha-help-popover::after {
+  content: '';
+  position: absolute;
+  top: -6px;
+  left: 50%;
+  transform: translateX(-50%);
+  width: 12px;
+  height: 12px;
+  background: rgba(2, 6, 23, 0.95);
+  border-left: 1px solid rgba(59, 130, 246, 0.35);
+  border-top: 1px solid rgba(59, 130, 246, 0.35);
+  border-radius: 2px;
+  transform-origin: center;
+  transform: translateX(-50%) rotate(45deg);
+}
+
+.ha-help-title {
+  font-weight: 700;
+  letter-spacing: 0.06em;
+  text-transform: uppercase;
+  font-size: 11px;
+  margin-bottom: 6px;
+  color: rgba(248, 250, 252, 0.85);
+}
+
+.ha-help-popover ul {
+  margin: 6px 0 8px;
+  padding-left: 18px;
+}
+
+.ha-help-popover li {
+  margin-bottom: 4px;
+  list-style: disc;
+  color: rgba(226, 232, 240, 0.9);
+}
+
+.ha-help-popover li strong {
+  color: #fbbf24;
+}
+
+.ha-help-popover .ha-btn {
+  width: 100%;
+  margin-top: 6px;
+}
+
+.ha-tooltip {
+  position: fixed;
+  transform: translate(-50%, -110%);
+  background: rgba(2, 6, 23, 0.95);
+  border: 1px solid rgba(59, 130, 246, 0.35);
+  color: #f8fafc;
+  font-size: 11px;
+  padding: 6px 10px;
+  border-radius: 8px;
+  pointer-events: none;
+  white-space: normal;
+  max-width: 220px;
+  text-align: center;
+  box-shadow: 0 12px 30px rgba(2, 6, 23, 0.5);
+  z-index: 2147483647;
+}
+
+.ha-tooltip::after {
+  content: '';
+  position: absolute;
+  width: 10px;
+  height: 10px;
+  background: inherit;
+  border-left: 1px solid rgba(59, 130, 246, 0.35);
+  border-bottom: 1px solid rgba(59, 130, 246, 0.35);
+  transform: rotate(45deg);
+  bottom: -6px;
+  left: 50%;
+  margin-left: -5px;
+}
+
 .ha-input,
 .ha-textarea {
   width: 100%;
@@ -110,6 +308,561 @@ const STYLES = `
   resize: vertical;
 }
 
+.ha-layer-tool {
+  width: 100%;
+  border-radius: 14px;
+  border: 1px solid rgba(148, 163, 184, 0.35);
+  padding: 12px;
+  display: flex;
+  flex-direction: column;
+  gap: 10px;
+}
+
+.ha-layer-header {
+  display: flex;
+  align-items: flex-start;
+  justify-content: space-between;
+  gap: 12px;
+}
+
+.ha-layer-title {
+  font-size: 13px;
+  letter-spacing: 0.08em;
+  text-transform: uppercase;
+  font-weight: 700;
+}
+
+.ha-layer-subtitle {
+  font-size: 11px;
+  opacity: 0.75;
+}
+
+.ha-layer-controls {
+  display: flex;
+  gap: 8px;
+}
+
+.ha-layer-controls .ha-btn {
+  padding: 6px 10px;
+  font-size: 12px;
+  width: auto;
+}
+
+.ha-layer-hint {
+  font-size: 11px;
+  letter-spacing: 0.04em;
+  text-transform: uppercase;
+  color: rgba(226, 232, 240, 0.7);
+}
+
+.ha-layer-list {
+  display: flex;
+  flex-direction: column;
+  gap: 10px;
+  max-height: 220px;
+  overflow-y: auto;
+  padding-right: 2px;
+  scrollbar-width: thin;
+  scrollbar-color: rgba(148, 163, 184, 0.3) transparent;
+}
+
+.ha-layer-list::-webkit-scrollbar {
+  width: 6px;
+}
+
+.ha-layer-list::-webkit-scrollbar-thumb {
+  background: rgba(148, 163, 184, 0.25);
+  border-radius: 10px;
+}
+
+.ha-layer-list:hover::-webkit-scrollbar-thumb {
+  background: rgba(148, 163, 184, 0.5);
+}
+
+.ha-layer-card {
+  border-radius: 12px;
+  border: 1px solid rgba(59, 130, 246, 0.25);
+  padding: 10px;
+  display: flex;
+  flex-direction: column;
+  gap: 8px;
+}
+
+.ha-layer-meta {
+  display: flex;
+  gap: 10px;
+  align-items: center;
+}
+
+.ha-layer-index {
+  width: 30px;
+  height: 30px;
+  border-radius: 12px;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  font-size: 12px;
+  font-weight: 700;
+  border: 1px solid rgba(125, 211, 252, 0.4);
+  color: #e0f2fe;
+}
+
+.ha-layer-label {
+  font-weight: 600;
+  font-size: 13px;
+  word-break: break-word;
+}
+
+.ha-layer-selector {
+  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
+  font-size: 11px;
+  color: #94a3b8;
+  word-break: break-word;
+}
+
+.ha-layer-card-actions {
+  display: flex;
+  gap: 8px;
+}
+
+.ha-layer-card-actions .ha-btn {
+  flex: 1;
+  padding: 6px 0;
+  font-size: 12px;
+}
+
+.ha-layer-empty {
+  font-size: 12px;
+  text-align: center;
+  padding: 16px 0;
+  color: rgba(226, 232, 240, 0.7);
+}
+
+.ha-layer-thumb {
+  width: 34px;
+  height: 34px;
+  border-radius: 10px;
+  border: 1px solid rgba(148, 163, 184, 0.35);
+  background: rgba(15, 23, 42, 0.7);
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  flex-shrink: 0;
+}
+
+.ha-layer-thumb-border {
+  width: 76%;
+  height: 76%;
+  border-radius: 8px;
+  border: 1px solid rgba(148, 163, 184, 0.3);
+  padding: 2px;
+  box-sizing: border-box;
+  display: flex;
+  align-items: center;
+  justify-content: center;
+}
+
+.ha-layer-thumb-shape {
+  width: 100%;
+  height: 100%;
+  border-radius: 6px;
+  background: rgba(59, 130, 246, 0.35);
+}
+
+.ha-layer-thumb-shape.has-image {
+  background-image: linear-gradient(
+      45deg,
+      rgba(148, 163, 184, 0.25) 25%,
+      transparent 25%
+    ),
+    linear-gradient(-45deg, rgba(148, 163, 184, 0.2) 25%, transparent 25%),
+    linear-gradient(45deg, transparent 75%, rgba(148, 163, 184, 0.25) 75%),
+    linear-gradient(-45deg, transparent 75%, rgba(148, 163, 184, 0.25) 75%);
+  background-size: 12px 12px;
+  background-position: 0 0, 0 6px, 6px -6px, -6px 0;
+}
+
+.ha-layer-meta-body {
+  flex: 1;
+  display: flex;
+  flex-direction: column;
+  gap: 2px;
+}
+
+.ha-layer-meta-top {
+  display: flex;
+  align-items: center;
+  gap: 8px;
+}
+
+.ha-layer-dimensions {
+  font-size: 11px;
+  text-transform: uppercase;
+  letter-spacing: 0.08em;
+  color: rgba(226, 232, 240, 0.7);
+}
+
+.ha-bridge-floating {
+  width: 360px;
+  padding: 14px;
+  display: flex;
+  flex-direction: column;
+  gap: 0;
+}
+
+.ha-bridge-floating-header {
+  display: flex;
+  align-items: flex-start;
+  justify-content: space-between;
+  gap: 12px;
+  margin-bottom: 10px;
+}
+
+.ha-bridge-card {
+  display: flex;
+  flex-direction: column;
+  gap: 12px;
+  padding: 12px;
+  border-radius: 14px;
+  border: 1px solid rgba(148, 163, 184, 0.3);
+  background: rgba(15, 23, 42, 0.65);
+}
+
+.ha-bridge-header {
+  display: flex;
+  justify-content: space-between;
+  gap: 12px;
+  align-items: center;
+}
+
+.ha-bridge-monitor-row {
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+  gap: 12px;
+}
+
+.ha-bridge-status {
+  display: flex;
+  gap: 10px;
+  align-items: center;
+}
+
+.ha-status-dot {
+  width: 12px;
+  height: 12px;
+  border-radius: 50%;
+  background: rgba(148, 163, 184, 0.6);
+  box-shadow: 0 0 0 2px rgba(15, 23, 42, 0.4);
+}
+
+.ha-status-dot.is-ok {
+  background: #34d399;
+}
+
+.ha-status-dot.is-offline {
+  background: #f87171;
+}
+
+.ha-status-dot.is-idle {
+  background: #facc15;
+}
+
+.ha-bridge-title-text {
+  font-weight: 600;
+  font-size: 13px;
+}
+
+.ha-bridge-subtext {
+  font-size: 12px;
+  color: rgba(226, 232, 240, 0.75);
+}
+
+.ha-bridge-error {
+  font-size: 12px;
+  color: #fecaca;
+  background: rgba(248, 113, 113, 0.1);
+  border: 1px solid rgba(248, 113, 113, 0.35);
+  border-radius: 10px;
+  padding: 6px 8px;
+}
+
+.ha-bridge-offline {
+  display: flex;
+  flex-direction: column;
+  gap: 10px;
+  background: rgba(15, 23, 42, 0.55);
+  border: 1px solid rgba(248, 113, 113, 0.35);
+  border-radius: 12px;
+  padding: 10px;
+}
+
+.ha-bridge-offline-title {
+  font-weight: 600;
+  color: #fecaca;
+  font-size: 13px;
+}
+
+.ha-bridge-offline-text {
+  font-size: 12px;
+  color: rgba(226, 232, 240, 0.8);
+}
+
+.ha-bridge-field {
+  display: flex;
+  flex-direction: column;
+  gap: 6px;
+}
+
+.ha-bridge-label {
+  font-size: 12px;
+  text-transform: uppercase;
+  letter-spacing: 0.08em;
+  color: rgba(226, 232, 240, 0.75);
+}
+
+.ha-bridge-input {
+  display: flex;
+  gap: 8px;
+  align-items: center;
+}
+
+.ha-bridge-input .ha-input {
+  flex: 1;
+}
+
+.ha-bridge-command {
+  display: flex;
+  gap: 8px;
+  align-items: stretch;
+}
+
+.ha-bridge-command-text {
+  flex: 1;
+  background: rgba(2, 6, 23, 0.6);
+  border: 1px solid rgba(148, 163, 184, 0.3);
+  border-radius: 10px;
+  padding: 6px 8px;
+  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
+  font-size: 12px;
+  white-space: pre;
+  text-overflow: initial;
+  overflow-x: auto;
+  overflow-y: hidden;
+  min-height: 38px;
+  line-height: 1.4;
+}
+
+.ha-bridge-actions {
+  display: flex;
+  gap: 8px;
+}
+
+.ha-bridge-status-note {
+  font-size: 12px;
+  color: rgba(226, 232, 240, 0.8);
+}
+
+.ha-resize-handle {
+  position: absolute;
+  z-index: 2147483648;
+  background: rgba(148, 163, 184, 0.25);
+  border-radius: 999px;
+  transition: background 0.15s ease, opacity 0.15s ease;
+  opacity: 0.45;
+}
+
+.ha-resize-handle:hover {
+  opacity: 0.95;
+  background: rgba(59, 130, 246, 0.55);
+}
+
+.ha-resize-top-left,
+.ha-resize-top-right,
+.ha-resize-bottom-left,
+.ha-resize-bottom-right {
+  width: 14px;
+  height: 14px;
+}
+
+.ha-resize-top-left {
+  top: 2px;
+  left: 2px;
+  cursor: nwse-resize;
+}
+
+.ha-resize-top-right {
+  top: 2px;
+  right: 2px;
+  cursor: nesw-resize;
+}
+
+.ha-resize-bottom-left {
+  bottom: 2px;
+  left: 2px;
+  cursor: nesw-resize;
+}
+
+.ha-resize-bottom-right {
+  bottom: 2px;
+  right: 2px;
+  cursor: nwse-resize;
+}
+
+.ha-resize-top,
+.ha-resize-bottom {
+  width: 40%;
+  height: 8px;
+  left: 50%;
+  transform: translateX(-50%);
+}
+
+.ha-resize-top {
+  top: 0;
+  cursor: ns-resize;
+}
+
+.ha-resize-bottom {
+  bottom: 0;
+  cursor: ns-resize;
+}
+
+.ha-resize-left,
+.ha-resize-right {
+  width: 8px;
+  height: 40%;
+  top: 30%;
+}
+
+.ha-resize-left {
+  left: 0;
+  cursor: ew-resize;
+}
+
+.ha-resize-right {
+  right: 0;
+  cursor: ew-resize;
+}
+
+.ha-layer-floating {
+  width: 320px;
+  padding: 14px;
+}
+
+.ha-layer-floating-header {
+  display: flex;
+  align-items: flex-start;
+  justify-content: space-between;
+  gap: 12px;
+}
+
+.ha-layer-floating-actions {
+  display: flex;
+  gap: 6px;
+}
+
+.ha-layer-floating-actions .ha-btn {
+  width: auto;
+  padding: 6px 10px;
+  font-size: 12px;
+}
+
+.ha-layer-icon-btn {
+  width: 32px;
+  height: 32px;
+  border-radius: 10px;
+  border: 1px solid rgba(148, 163, 184, 0.35);
+  background: rgba(15, 23, 42, 0.85);
+  display: inline-flex;
+  align-items: center;
+  justify-content: center;
+  cursor: pointer;
+  transition: transform 0.1s ease, border-color 0.1s ease;
+}
+
+.ha-layer-icon-btn:hover {
+  transform: translateY(-1px);
+  border-color: rgba(56, 189, 248, 0.6);
+}
+
+.ha-layer-icon-btn.is-muted {
+  border-color: rgba(244, 63, 94, 0.6);
+  opacity: 0.8;
+}
+
+.ha-layer-eye {
+  width: 18px;
+  height: 10px;
+  border: 2px solid rgba(148, 163, 184, 0.8);
+  border-radius: 999px / 80%;
+  position: relative;
+  display: inline-flex;
+  align-items: center;
+  justify-content: center;
+}
+
+.ha-layer-eye-pupil {
+  width: 6px;
+  height: 6px;
+  border-radius: 999px;
+  background: rgba(56, 189, 248, 0.9);
+  display: block;
+}
+
+.ha-layer-icon-btn.is-muted .ha-layer-eye {
+  border-color: rgba(248, 113, 113, 0.8);
+}
+
+.ha-layer-icon-btn.is-muted .ha-layer-eye-pupil {
+  background: rgba(248, 113, 113, 0.9);
+}
+
+.ha-layer-footer {
+  margin-top: 10px;
+}
+
+.ha-switch {
+  position: relative;
+  width: 42px;
+  height: 24px;
+  display: inline-block;
+}
+
+.ha-switch input {
+  opacity: 0;
+  width: 0;
+  height: 0;
+}
+
+.ha-switch-slider {
+  position: absolute;
+  cursor: pointer;
+  inset: 0;
+  background: rgba(148, 163, 184, 0.4);
+  border-radius: 999px;
+  transition: background 0.2s ease;
+}
+
+.ha-switch-slider::after {
+  content: '';
+  position: absolute;
+  height: 18px;
+  width: 18px;
+  left: 3px;
+  top: 3px;
+  border-radius: 999px;
+  background: #ffffff;
+  transition: transform 0.2s ease;
+}
+
+.ha-switch input:checked + .ha-switch-slider {
+  background: #34d399;
+}
+
+.ha-switch input:checked + .ha-switch-slider::after {
+  transform: translateX(18px);
+}
+
 @media (prefers-reduced-motion: reduce) {
   .ha-panel {
     transition: none;
